<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Render</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="highlight-light">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="highlight-dark" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #ffffff;
            --text-primary: #24292f;
            --text-secondary: #656d76;
            --text-muted: #8b949e;
            --border-primary: #d1d9e0;
            --border-secondary: #eaeef2;
            --accent-primary: #0969da;
            --accent-hover: #0860ca;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #7d8590;
            --text-muted: #656d76;
            --border-primary: #30363d;
            --border-secondary: #21262d;
            --accent-primary: #2f81f7;
            --accent-hover: #1f6feb;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-primary);
            text-decoration: none;
            cursor: pointer;
        }

        .logo:hover {
            color: var(--accent-hover);
        }

        .theme-toggle {
            background: none;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 0.5rem;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }

        .theme-toggle:hover {
            background-color: var(--bg-tertiary);
            transform: scale(1.05);
        }

        /* Main Content */
        .main-content {
            margin-top: 80px;
            margin-bottom: 80px;
            min-height: calc(100vh - 160px);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .intro-section {
            text-align: center;
            padding: 3rem 0;
        }

        .intro-section h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .intro-section p {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Input Section */
        .input-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .repo-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
        }

        .repo-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.1);
        }

        .render-btn {
            padding: 0.75rem 1.5rem;
            background-color: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .render-btn:hover:not(:disabled) {
            background-color: var(--accent-hover);
            transform: translateY(-1px);
        }

        .render-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
        }

        .toggle-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .toggle-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .toggle-btn:hover:not(.active) {
            background: var(--bg-tertiary);
        }

        /* Results */
        .results-container {
            margin-top: 2rem;
            display: none;
        }

        .results-container.show {
            display: block;
        }

        .repo-info {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .repo-info h3 {
            margin-bottom: 0.5rem;
            color: var(--accent-primary);
        }

        .repo-stats {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .stat {
            color: var(--text-secondary);
        }

        /* Sidebar */
        .content-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            margin-top: 1rem;
            min-width: 0; /* Allow grid items to shrink below content size */
        }

        .sidebar {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1rem;
            padding-bottom: 80px; /* Extra padding to ensure footer doesn't block content */
            max-height: calc(100vh - 120px); /* Limit height to viewport minus header space */
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: hidden; /* Hide horizontal scroll */
            position: sticky;
            top: 100px;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .files-container {
            min-width: 0; /* Allow container to shrink */
            overflow-x: hidden; /* Prevent horizontal overflow */
        }

        .sidebar h3 {
            margin-bottom: 1rem;
            margin-top: 0;
            color: var(--text-primary);
            font-size: 1rem;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .file-tree {
            list-style: none;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 0;
            padding: 0;
            height: auto; /* Ensure the tree can expand to full height */
            flex-grow: 1; /* Allow it to take available space */
        }

        .file-tree li {
            padding: 0.2rem 0;
            word-wrap: break-word; /* Handle long filenames */
        }

        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border-primary);
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .file-tree a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .file-tree a:hover {
            text-decoration: underline;
        }

        /* File sections */
        .file-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden;
            min-width: 0; /* Allow sections to shrink */
            max-width: 100%; /* Prevent overflow */
        }

        .file-header {
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-header h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .file-size {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .file-content {
            padding: 0;
            overflow-x: auto;
            max-width: 100%;
        }

        /* Add padding for markdown content specifically */
        .file-content .markdown-content {
            padding: 1rem 1.5rem;
        }

        /* Add minimal padding for non-code content */
        .file-content > *:not(.hljs-container):not(pre):not(.code-block-wrapper) {
            padding-left: 1rem;
            padding-right: 1rem;
        }

        .file-content pre {
            margin: 0;
            padding: 1rem;
            overflow-x: auto;
            background: transparent;
            font-size: 0.9rem;
            line-height: 1.4;
            max-width: 100%;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .file-content code {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            word-wrap: break-word;
            white-space: pre-wrap;
            display: block;
            overflow-x: auto;
        }

        /* Ensure code blocks don't overflow */
        .hljs {
            overflow-x: auto !important;
            max-width: 100% !important;
            word-wrap: break-word !important;
            white-space: pre-wrap !important;
        }

        .hljs-container {
            overflow-x: auto;
            max-width: 100%;
            background: var(--bg-tertiary);
            border-radius: 0 0 6px 6px;
            margin: 0;
        }

        /* Code block wrappers with language headers */
        .code-block-wrapper {
            margin: 1rem 0;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-secondary);
        }

        .code-block-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            border-radius: 6px 6px 0 0;
        }

        .code-language {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-weight: 500;
            text-transform: lowercase;
        }

        .code-block-wrapper .hljs-container {
            border-radius: 0 0 6px 6px;
            border: none;
            margin: 0;
        }

        /* Better handling of long lines in code */
        .file-content .hljs {
            tab-size: 4;
            -moz-tab-size: 4;
        }

        /* Ensure proper line breaking for long URLs and strings */
        .hljs .hljs-string,
        .hljs .hljs-comment {
            word-break: break-word;
            white-space: pre-wrap;
        }

        /* GitHub Flavored Markdown Styles */
        .file-content h1, .file-content h2, .file-content h3, 
        .file-content h4, .file-content h5, .file-content h6 {
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            line-height: 1.25;
            color: var(--text-primary);
            border-bottom: none;
        }

        .file-content h1 {
            font-size: 2rem;
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 0.5rem;
        }

        .file-content h2 {
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border-secondary);
            padding-bottom: 0.3rem;
        }

        .file-content h3 { font-size: 1.25rem; }
        .file-content h4 { font-size: 1rem; }
        .file-content h5 { font-size: 0.875rem; }
        .file-content h6 { font-size: 0.85rem; color: var(--text-secondary); }

        .file-content p {
            margin: 0 0 1rem 0;
            line-height: 1.6;
        }

        .file-content blockquote {
            margin: 0 0 1rem 0;
            padding: 0 1rem;
            color: var(--text-secondary);
            border-left: 4px solid var(--border-primary);
            background-color: var(--bg-secondary);
        }

        .file-content ul, .file-content ol {
            margin: 0 0 1rem 0;
            padding-left: 2rem;
        }

        .file-content li {
            margin: 0.25rem 0;
            line-height: 1.6;
        }

        /* Task List Styles */
        .file-content .task-list-item {
            list-style: none;
            margin-left: -1.5rem;
        }

        .file-content .task-list-item-checkbox {
            margin-right: 0.5rem;
            margin-left: 0;
        }

        /* Table Styles */
        .table-wrapper {
            overflow-x: auto;
            margin: 1rem 0;
        }

        .markdown-table {
            border-collapse: collapse;
            border-spacing: 0;
            width: 100%;
            max-width: 100%;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-primary);
        }

        .markdown-table th,
        .markdown-table td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid var(--border-primary);
            line-height: 1.6;
        }

        .markdown-table th {
            background-color: var(--bg-secondary);
            font-weight: 600;
            color: var(--text-primary);
        }

        .markdown-table tr:nth-child(even) {
            background-color: var(--bg-secondary);
        }

        .markdown-table tr:hover {
            background-color: var(--bg-tertiary);
        }

        /* Inline Code */
        .file-content code:not(.hljs) {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }

        /* Horizontal Rules */
        .file-content hr {
            border: none;
            border-top: 1px solid var(--border-primary);
            margin: 2rem 0;
        }

        /* Images */
        .file-content img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 1rem 0;
        }

        /* Links */
        .file-content a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .file-content a:hover {
            text-decoration: underline;
        }

        /* Emphasis */
        .file-content strong {
            font-weight: 600;
            color: var(--text-primary);
        }

        .file-content em {
            font-style: italic;
        }

        /* GitHub-specific features */
        .markdown-content {
            line-height: 1.6;
            /* Padding is handled by .file-content .markdown-content rule above */
        }

        .mention {
            color: var(--accent-primary);
            font-weight: 500;
        }

        .issue-reference {
            color: var(--accent-primary);
            font-weight: 500;
        }

        .commit-sha {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.9em;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }

        /* Better spacing for markdown content */
        .markdown-content > *:first-child {
            margin-top: 0;
        }

        .markdown-content > *:last-child {
            margin-bottom: 0;
        }

        /* LLM View */
        .llm-view {
            display: none;
        }

        .llm-view.show {
            display: block;
        }

        .llm-textarea {
            width: 100%;
            height: 60vh;
            padding: 1rem;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            resize: vertical;
        }

        .copy-hint {
            margin-top: 0.5rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            color: var(--text-secondary);
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-primary);
            border-top: 2px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Footer - hidden by default, shown when scrolling near bottom */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border-primary);
            padding: 1rem 2rem;
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
            transform: translateY(100%); /* Hidden by default */
            transition: transform 0.3s ease-in-out;
            z-index: 100;
        }
        
        .footer.show {
            transform: translateY(0); /* Show when near bottom */
        }

        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
            margin-left: 0.5rem;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .github-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 0.5rem;
            vertical-align: text-bottom;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }

            .container {
                padding: 1rem;
                max-width: 100%;
                overflow-x: hidden;
            }

            .input-group {
                flex-direction: column;
            }

            .content-layout {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .sidebar {
                position: static;
                max-height: 300px; /* Limit height on mobile */
                overflow-y: auto; /* Enable vertical scrolling on mobile */
                overflow-x: hidden; /* Hide horizontal scroll on mobile */
            }

            .intro-section h1 {
                font-size: 2rem;
            }

            .repo-stats {
                gap: 1rem;
                flex-direction: column;
            }

            .pagination {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.25rem;
            }

            .pagination button {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
                min-width: 35px;
            }

            .file-content pre {
                font-size: 0.8rem;
                padding: 0.75rem;
                overflow-x: auto;
                white-space: pre;
                word-wrap: normal;
            }

            .file-content code {
                white-space: pre;
                word-wrap: normal;
            }

            /* Reduce padding on mobile for better space utilization */
            .file-content .markdown-content {
                padding: 0.75rem 1rem;
            }

            .file-content > *:not(.hljs-container):not(pre):not(.code-block-wrapper) {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }

            .files-container {
                overflow-x: hidden;
                max-width: 100%;
            }

            .file-section {
                max-width: 100%;
                overflow-x: hidden;
            }
        }

        /* Tablet styles */
        @media (min-width: 769px) and (max-width: 1024px) {
            .content-layout {
                grid-template-columns: 250px 1fr;
                gap: 1.5rem;
            }

            .container {
                padding: 1.5rem;
                max-width: 100%;
            }

            .sidebar {
                font-size: 0.85rem;
                max-height: 400px; /* Limit height on tablet */
                overflow-y: auto; /* Enable vertical scrolling on tablet */
                overflow-x: hidden; /* Hide horizontal scroll on tablet */
            }

            .pagination button {
                padding: 0.6rem 1rem;
            }

            .file-content pre {
                overflow-x: auto;
            }

            .files-container {
                min-width: 0;
                overflow-x: hidden;
            }
        }

        /* Large desktop styles */
        @media (min-width: 1400px) {
            .container {
                max-width: 1400px;
            }

            .content-layout {
                grid-template-columns: 350px 1fr;
                gap: 2.5rem;
            }
        }

        /* Pagination styles */
        .pagination-container {
            margin: 2rem 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .pagination-info {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .pagination {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .pagination button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            min-width: 40px;
        }

        .pagination button:hover:not(:disabled) {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination button.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .pagination .ellipsis {
            padding: 0.5rem;
            color: var(--text-muted);
        }

        /* Files per page selector */
        .files-per-page {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .files-per-page label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .files-per-page select {
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="#" class="logo" onclick="refreshApp()">Git Render</a>
        <button class="theme-toggle" onclick="toggleTheme()" id="theme-btn">🌙</button>
    </header>

    <main class="main-content">
        <div class="container">
            <section class="intro-section">
                <h1>Git Render</h1>
                <p>Transform any GitHub repository into a single, searchable HTML page with syntax highlighting and markdown rendering. Perfect for code review and exploration.</p>
            </section>

            <section class="input-section">
                <div class="input-group">
                    <input type="text" 
                           class="repo-input" 
                           id="repo-input" 
                           placeholder="https://github.com/username/repository" 
                           value="">
                    <button class="render-btn" onclick="renderRepository()" id="render-btn">
                        Render Repository
                    </button>
                </div>
                <div class="input-group" style="margin-top: 1rem;">
                    <input type="password" 
                           class="repo-input" 
                           id="github-token" 
                           placeholder="GitHub Personal Access Token (optional - helps avoid rate limits)" 
                           value="">
                    <button class="toggle-btn" onclick="toggleTokenVisibility()" id="token-toggle" style="min-width: 120px;">
                        👁️ Show Token
                    </button>
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
                    💡 <strong>Tip:</strong> Add a GitHub token to avoid rate limits. 
                    <a href="https://github.com/settings/tokens" target="_blank" style="color: var(--accent-primary);">Create one here</a> 
                    with 'public_repo' scope.
                </div>
                <div id="loading" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Processing repository...</span>
                </div>
            </section>

            <div class="results-container" id="results-container">
                <div class="view-toggle">
                    <button class="toggle-btn active" onclick="showView('human')" id="human-btn">👤 Human View</button>
                    <button class="toggle-btn" onclick="showView('llm')" id="llm-btn">🤖 LLM View</button>
                </div>

                <div class="repo-info" id="repo-info" style="display: none;">
                    <h3 id="repo-name"></h3>
                    <p id="repo-description"></p>
                    <div class="repo-stats">
                        <span class="stat">Files: <strong id="file-count">0</strong></span>
                        <span class="stat">Size: <strong id="total-size">0 B</strong></span>
                        <span class="stat">Language: <strong id="main-language">-</strong></span>
                    </div>
                </div>

                <div class="human-view" id="human-view">
                    <div class="files-per-page">
                        <label for="files-per-page-select">Files per page:</label>
                        <select id="files-per-page-select" onchange="changeFilesPerPage()">
                            <option value="5">5</option>
                            <option value="10" selected>10</option>
                            <option value="20">20</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                            <option value="-1">All</option>
                        </select>
                    </div>
                    
                    <div class="content-layout">
                        <aside class="sidebar">
                            <h3>Files</h3>
                            <ul class="file-tree" id="file-tree"></ul>
                        </aside>
                        <div class="files-container" id="files-container"></div>
                    </div>
                    
                    <div class="pagination-container" id="pagination-container" style="display: none;">
                        <div class="pagination-info" id="pagination-info"></div>
                        <div class="pagination" id="pagination"></div>
                    </div>
                </div>

                <div class="llm-view" id="llm-view">
                    <h3>🤖 LLM View - CXML Format</h3>
                    <p>Copy the text below and paste it to an LLM for analysis:</p>
                    <textarea class="llm-textarea" id="llm-textarea" readonly></textarea>
                    <div class="copy-hint">
                        💡 <strong>Tip:</strong> Click in the text area and press Ctrl+A (Cmd+A on Mac) to select all, then Ctrl+C (Cmd+C) to copy.
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        Created by Mohamed Elashri
        <a href="https://github.com/MohamedElashri/grender" target="_blank">
            <svg class="github-icon" viewBox="0 0 16 16" fill="currentColor">
                <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
            </svg>
        </a>
    </footer>

    <script>
        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e.error);
            console.error('Error in file:', e.filename, 'at line:', e.lineno);
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);
        });
        
        // Configure marked.js for GitHub Flavored Markdown
        marked.setOptions({
            gfm: true,              // Enable GitHub Flavored Markdown
            breaks: true,           // Enable line breaks
            tables: true,           // Enable tables
            sanitize: false,        // Don't sanitize HTML (we trust GitHub content)
            smartLists: true,       // Use smarter list behavior
            smartypants: false,     // Don't use "smart" typography
            headerIds: true,        // Generate header IDs
            mangle: false,          // Don't mangle header IDs
        });
        
        // Configure marked renderer for better GitHub compatibility
        const renderer = new marked.Renderer();
        
        // Custom table rendering with GitHub classes
        renderer.table = function(header, body) {
            return `<div class="table-wrapper"><table class="markdown-table">
                <thead>${header}</thead>
                <tbody>${body}</tbody>
            </table></div>`;
        };
        
        // Custom code block rendering with syntax highlighting
        renderer.code = function(code, language) {
            if (language && hljs.getLanguage(language)) {
                try {
                    const highlighted = hljs.highlight(code, { language: language });
                    return `<div class="code-block-wrapper">
                        <div class="code-block-header">
                            <span class="code-language">${language}</span>
                        </div>
                        <pre class="hljs-container"><code class="hljs language-${language}">${highlighted.value}</code></pre>
                    </div>`;
                } catch (error) {
                    console.warn('Syntax highlighting failed for language:', language, error);
                }
            }
            // Fallback to auto-detection or plain text
            try {
                const highlighted = hljs.highlightAuto(code);
                const detectedLanguage = highlighted.language || 'text';
                return `<div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">${detectedLanguage}</span>
                    </div>
                    <pre class="hljs-container"><code class="hljs">${highlighted.value}</code></pre>
                </div>`;
            } catch (error) {
                const escapedCode = code
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                return `<pre class="code-block-wrapper"><code>${escapedCode}</code></pre>`;
            }
        };
        
        // Custom checkbox rendering for task lists
        renderer.listitem = function(text) {
            const isTaskList = /^\s*\[[ xX]\]\s+/.test(text);
            if (isTaskList) {
                const isChecked = /^\s*\[[xX]\]\s+/.test(text);
                const cleanText = text.replace(/^\s*\[[ xX]\]\s+/, '');
                return `<li class="task-list-item">
                    <input type="checkbox" class="task-list-item-checkbox" ${isChecked ? 'checked' : ''} disabled>
                    ${cleanText}
                </li>`;
            }
            return `<li>${text}</li>`;
        };
        
        // Custom link rendering for better security
        renderer.link = function(href, title, text) {
            const titleAttr = title ? ` title="${title}"` : '';
            const target = href.startsWith('http') ? ' target="_blank" rel="noopener noreferrer"' : '';
            return `<a href="${href}"${titleAttr}${target}>${text}</a>`;
        };
        
        // Apply the custom renderer
        marked.setOptions({ renderer: renderer });
        
        let currentTheme = 'light';
        let currentView = 'human';
        let repositoryData = null;
        
        // Pagination variables
        let currentPage = 1;
        let filesPerPage = 10;
        let totalPages = 1;

        // Theme management
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            const themeBtn = document.getElementById('theme-btn');
            if (themeBtn) {
                themeBtn.textContent = currentTheme === 'light' ? '🌙' : '☀️';
            }
            
            // Update highlight.js theme
            const lightLink = document.getElementById('highlight-light');
            const darkLink = document.getElementById('highlight-dark');
            
            if (lightLink && darkLink) {
                if (currentTheme === 'dark') {
                    lightLink.disabled = true;
                    darkLink.disabled = false;
                } else {
                    lightLink.disabled = false;
                    darkLink.disabled = true;
                }
            }
            
            localStorage.setItem('git-render-theme', currentTheme);
        }

        // Initialize theme from localStorage
        function initTheme() {
            const savedTheme = localStorage.getItem('git-render-theme');
            if (savedTheme && savedTheme !== currentTheme) {
                toggleTheme();
            }
        }

        // View switching
        function showView(view) {
            currentView = view;
            const humanView = document.getElementById('human-view');
            const llmView = document.getElementById('llm-view');
            const humanBtn = document.getElementById('human-btn');
            const llmBtn = document.getElementById('llm-btn');

            if (!humanView || !llmView || !humanBtn || !llmBtn) {
                console.warn('View switching elements not found');
                return;
            }

            if (view === 'human') {
                humanView.style.display = 'block';
                llmView.style.display = 'none';
                humanBtn.classList.add('active');
                llmBtn.classList.remove('active');
            } else {
                humanView.style.display = 'none';
                llmView.style.display = 'block';
                humanBtn.classList.remove('active');
                llmBtn.classList.add('active');
                
                // Auto-select text for easy copying
                setTimeout(() => {
                    const textarea = document.getElementById('llm-textarea');
                    if (textarea) {
                        textarea.focus();
                        textarea.select();
                    }
                }, 100);
            }
        }

        // Refresh app
        function refreshApp() {
            const repoInput = document.getElementById('repo-input');
            const resultsContainer = document.getElementById('results-container');
            const paginationContainer = document.getElementById('pagination-container');
            
            if (repoInput) repoInput.value = '';
            if (resultsContainer) resultsContainer.classList.remove('show');
            repositoryData = null;
            currentPage = 1;
            if (paginationContainer) paginationContainer.style.display = 'none';
        }

        // Pagination functions
        function changeFilesPerPage() {
            const select = document.getElementById('files-per-page-select');
            if (!select || !repositoryData) return;
            
            filesPerPage = parseInt(select.value);
            if (filesPerPage === -1) {
                filesPerPage = repositoryData.files.length; // Show all files
            }
            currentPage = 1;
            updatePagination();
            generateEnhancedFileSections();
        }

        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            generateEnhancedFileSections();
            updatePagination();
            
            // Scroll to top of files container
            const filesContainer = document.getElementById('files-container');
            if (filesContainer) {
                filesContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function updatePagination() {
            if (!repositoryData || !repositoryData.files) return;
            
            const totalFiles = repositoryData.files.length;
            totalPages = Math.ceil(totalFiles / filesPerPage);
            
            const paginationContainer = document.getElementById('pagination-container');
            const paginationInfo = document.getElementById('pagination-info');
            const pagination = document.getElementById('pagination');
            
            if (!paginationContainer || !paginationInfo || !pagination) {
                console.warn('Pagination elements not found');
                return;
            }
            
            // Show/hide pagination based on whether it's needed
            if (totalPages <= 1) {
                paginationContainer.style.display = 'none';
                return;
            } else {
                paginationContainer.style.display = 'flex';
            }
            
            // Update pagination info
            const startFile = (currentPage - 1) * filesPerPage + 1;
            const endFile = Math.min(currentPage * filesPerPage, totalFiles);
            paginationInfo.textContent = `Showing ${startFile}-${endFile} of ${totalFiles} files`;
            
            // Generate pagination buttons
            pagination.innerHTML = '';
            
            // Previous button
            const prevBtn = document.createElement('button');
            prevBtn.textContent = '‹ Previous';
            prevBtn.disabled = currentPage === 1;
            prevBtn.onclick = () => goToPage(currentPage - 1);
            pagination.appendChild(prevBtn);
            
            // Page numbers
            const maxVisiblePages = window.innerWidth < 768 ? 3 : 7; // Fewer pages on mobile
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            // Adjust start page if we're near the end
            if (endPage - startPage < maxVisiblePages - 1) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            // First page and ellipsis
            if (startPage > 1) {
                const firstBtn = document.createElement('button');
                firstBtn.textContent = '1';
                firstBtn.onclick = () => goToPage(1);
                pagination.appendChild(firstBtn);
                
                if (startPage > 2) {
                    const ellipsis = document.createElement('span');
                    ellipsis.className = 'ellipsis';
                    ellipsis.textContent = '...';
                    pagination.appendChild(ellipsis);
                }
            }
            
            // Page number buttons
            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('button');
                pageBtn.textContent = i.toString();
                pageBtn.className = i === currentPage ? 'active' : '';
                pageBtn.onclick = () => goToPage(i);
                pagination.appendChild(pageBtn);
            }
            
            // Last page and ellipsis
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    const ellipsis = document.createElement('span');
                    ellipsis.className = 'ellipsis';
                    ellipsis.textContent = '...';
                    pagination.appendChild(ellipsis);
                }
                
                const lastBtn = document.createElement('button');
                lastBtn.textContent = totalPages.toString();
                lastBtn.onclick = () => goToPage(totalPages);
                pagination.appendChild(lastBtn);
            }
            
            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.textContent = 'Next ›';
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.onclick = () => goToPage(currentPage + 1);
            pagination.appendChild(nextBtn);
        }

        // Responsive files per page adjustment
        function adjustFilesPerPageForScreen() {
            const width = window.innerWidth;
            const select = document.getElementById('files-per-page-select');
            
            if (!select) return;
            
            // Auto-adjust files per page based on screen size if not manually set
            if (!select.dataset.manuallySet) {
                if (width < 768) { // Mobile
                    filesPerPage = 5;
                    select.value = '5';
                } else if (width < 1024) { // Tablet
                    filesPerPage = 10;
                    select.value = '10';
                } else { // Desktop
                    filesPerPage = 20;
                    select.value = '20';
                }
            }
        }

        // Toggle GitHub token visibility
        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('github-token');
            const toggleBtn = document.getElementById('token-toggle');
            
            if (!tokenInput || !toggleBtn) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                toggleBtn.textContent = '🙈 Hide Token';
            } else {
                tokenInput.type = 'password';
                toggleBtn.textContent = '👁️ Show Token';
            }
        }

        // Get GitHub API headers with optional token
        function getGitHubHeaders() {
            const tokenInput = document.getElementById('github-token');
            const token = tokenInput ? tokenInput.value.trim() : '';
            const headers = {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'GitRender-WebApp'
            };
            
            if (token) {
                // Validate token format (GitHub tokens are usually 40 characters)
                if (token.length < 20) {
                    console.warn('GitHub token seems too short, please verify it\'s correct');
                }
                headers['Authorization'] = `token ${token}`;
            }
            
            return headers;
        }

        // Check GitHub API rate limit status
        async function checkRateLimit() {
            try {
                const headers = getGitHubHeaders();
                const response = await fetch('https://api.github.com/rate_limit', { headers });
                
                if (response.ok) {
                    const rateLimit = await response.json();
                    const remaining = rateLimit.rate.remaining;
                    const resetTime = new Date(rateLimit.rate.reset * 1000);
                    
                    console.log(`GitHub API: ${remaining} requests remaining, resets at ${resetTime.toLocaleTimeString()}`);
                    
                    if (remaining < 10) {
                        const tokenInput = document.getElementById('github-token');
                        const token = tokenInput ? tokenInput.value.trim() : '';
                        if (!token) {
                            alert(`Warning: Only ${remaining} API requests remaining. Consider adding a GitHub token to avoid rate limits.`);
                        }
                    }
                    
                    return rateLimit;
                }
            } catch (error) {
                console.warn('Could not check rate limit:', error);
            }
            return null;
        }

        // Extract repository info from URL
        function parseRepoUrl(url) {
            const match = url.match(/github\.com\/([^\/]+)\/([^\/\?#]+)/);
            if (!match) return null;
            
            const owner = match[1];
            let repo = match[2];
            
            // Remove .git suffix if present
            if (repo.endsWith('.git')) {
                repo = repo.slice(0, -4);
            }
            
            return { owner, repo };
        }

        // Format file size
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KiB', 'MiB', 'GiB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Get file extension
        function getFileExtension(filename) {
            return filename.split('.').pop().toLowerCase();
        }

        // Check if file is markdown
        function isMarkdownFile(filename) {
            const ext = getFileExtension(filename);
            return ['md', 'markdown', 'mdown', 'mkd', 'mkdn'].includes(ext);
        }

        // Enhanced file categorization with better binary detection
        const BINARY_EXTENSIONS = new Set([
            'png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico',
            'pdf', 'zip', 'tar', 'gz', 'bz2', 'xz', '7z', 'rar',
            'mp3', 'mp4', 'mov', 'avi', 'mkv', 'wav', 'ogg', 'flac',
            'ttf', 'otf', 'eot', 'woff', 'woff2',
            'so', 'dll', 'dylib', 'class', 'jar', 'exe', 'bin',
            'deb', 'rpm', 'dmg', 'pkg', 'msi'
        ]);

        // Known text file extensions that should never be treated as binary
        const TEXT_EXTENSIONS = new Set([
            'txt', 'md', 'markdown', 'rst', 'py', 'js', 'ts', 'html', 'css', 'scss', 'sass',
            'json', 'xml', 'yaml', 'yml', 'toml', 'ini', 'cfg', 'conf', 'config',
            'sh', 'bash', 'zsh', 'fish', 'ps1', 'bat', 'cmd',
            'c', 'cpp', 'cxx', 'cc', 'h', 'hpp', 'hxx',
            'java', 'kt', 'scala', 'go', 'rs', 'swift', 'dart',
            'php', 'rb', 'pl', 'pm', 'r', 'julia', 'jl',
            'sql', 'sqlite', 'prisma',
            'dockerfile', 'makefile', 'cmake', 'gradle',
            'gitignore', 'gitattributes', 'editorconfig',
            'license', 'readme', 'changelog', 'todo', 'authors',
            'log', 'env', 'example'
        ]);

        function categorizeFile(filename, size) {
            // First, check for explicit git and repository metadata files that should NEVER be included
            const basename = filename.split('/').pop().toLowerCase();
            
            // EXPLICIT DEBUG: Log every call to this function for .gitattributes
            if (basename === '.gitattributes') {
                console.error('🚨 CATEGORIZING .gitattributes:', filename);
            }
            
            // Explicit list of files to ignore (case-insensitive)
            const explicitIgnoreList = [
                '.gitignore', '.gitattributes', '.gitmodules',
                'license', 'license.md', 'license.txt', 'licence', 'licence.md', 'licence.txt',
                'contributors.md', 'contributing.md', 'code_of_conduct.md', 'security.md', 'funding.yml',
                'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', 'poetry.lock', 'pipfile.lock',
                '.ds_store', 'thumbs.db', 'desktop.ini'
            ];
            
            if (explicitIgnoreList.includes(basename)) {
                console.error('🚨 IGNORING FILE:', filename, 'basename:', basename);
                return { include: false, reason: 'ignored', category: 'ignored' };
            }
            
            // Check if it's in a git directory
            if (filename.includes('/.git/') || filename.startsWith('.git/')) {
                return { include: false, reason: 'ignored', category: 'ignored' };
            }
            
            // Check directory patterns to ignore
            const ignoredDirPatterns = [
                '/.github/', '/.vscode/', '/.idea/', '/.vs/',
                '/node_modules/', '/__pycache__/', '/.pytest_cache/', '/.mypy_cache/',
                '/vendor/', '/deps/', '/target/', '/build/', '/dist/',
                '/.devcontainer/', '/.devenv/', '/.anthropic/', '/.openai/'
            ];
            
            if (ignoredDirPatterns.some(pattern => filename.includes(pattern)) ||
                filename.startsWith('.github/') ||
                filename.startsWith('.vscode/') ||
                filename.startsWith('node_modules/') ||
                filename.startsWith('__pycache__/')) {
                return { include: false, reason: 'ignored', category: 'ignored' };
            }
            
            // Check file size
            const maxSize = 100 * 1024; // 100KB limit
            if (size > maxSize) {
                return { include: false, reason: 'too_large', category: 'large' };
            }
            
            // Check if it's a known binary file
            const ext = getFileExtension(filename);
            if (BINARY_EXTENSIONS.has(ext)) {
                return { include: false, reason: 'binary', category: 'binary' };
            }
            
            // Check if it's a known text file
            if (TEXT_EXTENSIONS.has(ext)) {
                return { include: true, reason: 'ok', category: 'text' };
            }
            
            // Check for files without extensions that are commonly text
            if (!ext) {
                if (TEXT_EXTENSIONS.has(basename) || 
                    basename.includes('readme') || 
                    basename.includes('makefile') ||
                    basename.includes('dockerfile') ||
                    basename.includes('changelog') ||
                    basename.includes('todo')) {
                    return { include: true, reason: 'ok', category: 'text' };
                }
            }
            
            // For unknown extensions, assume text but be cautious
            return { include: true, reason: 'ok', category: 'text' };
        }

        // Legacy function for compatibility
        function shouldSkipFile(filename, size) {
            return !categorizeFile(filename, size).include;
        }

        // Enhanced repository contents fetching with categorization
        async function fetchRepositoryContents(owner, repo) {
            const loading = document.getElementById('loading');
            const renderBtn = document.getElementById('render-btn');
            
            loading.style.display = 'flex';
            renderBtn.disabled = true;
            
            try {
                const headers = getGitHubHeaders();
                
                // Fetch repository info
                const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
                if (!repoResponse.ok) {
                    if (repoResponse.status === 404) {
                        throw new Error('Repository not found or is private');
                    } else if (repoResponse.status === 403) {
                        const resetTime = repoResponse.headers.get('X-RateLimit-Reset');
                        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000).toLocaleTimeString() : 'unknown';
                        throw new Error(`API rate limit exceeded. Rate limit resets at ${resetDate}. Consider adding a GitHub token.`);
                    } else if (repoResponse.status === 401) {
                        throw new Error('Invalid GitHub token. Please check your token and try again.');
                    } else {
                        throw new Error(`Failed to fetch repository: ${repoResponse.status}`);
                    }
                }
                const repoInfo = await repoResponse.json();
                
                // Fetch repository tree
                const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${repoInfo.default_branch}?recursive=1`, { headers });
                if (!treeResponse.ok) {
                    if (treeResponse.status === 403) {
                        const resetTime = treeResponse.headers.get('X-RateLimit-Reset');
                        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000).toLocaleTimeString() : 'unknown';
                        throw new Error(`API rate limit exceeded while fetching repository tree. Rate limit resets at ${resetDate}. Consider adding a GitHub token.`);
                    }
                    throw new Error('Failed to fetch repository contents');
                }
                const treeData = await treeResponse.json();
                
                // Categorize all files - filter out ignored files immediately
                const allFiles = [];
                const categorizedFiles = {
                    rendered: [],
                    binary: [],
                    large: [],
                    ignored: [],
                    failed: [] // New category for files that failed to fetch
                };
                
                for (const item of treeData.tree) {
                    if (item.type === 'blob') {
                        const category = categorizeFile(item.path, item.size || 0);
                        
                        // EXPLICIT DEBUG: Check for .gitattributes in categorization
                        if (item.path === '.gitattributes' || item.path.endsWith('/.gitattributes')) {
                            console.error('🚨 PROCESSING .gitattributes - Category:', category);
                        }
                        
                        const fileInfo = {
                            path: item.path,
                            size: item.size || 0,
                            sha: item.sha,
                            category: category
                        };
                        
                        // Only add to allFiles if not ignored (to save memory and processing)
                        if (category.category !== 'ignored') {
                            allFiles.push(fileInfo);
                        } else {
                            console.log('✅ FILTERED OUT:', item.path, 'Category:', category.category);
                        }
                        
                        if (category.include) {
                            categorizedFiles.rendered.push(fileInfo);
                            console.log('📝 ADDED TO RENDERED:', item.path);
                        } else {
                            // Map category names to match the structure
                            const categoryKey = category.category === 'ignored' ? 'ignored' : 
                                              category.category === 'large' ? 'large' : 'binary';
                            categorizedFiles[categoryKey].push(fileInfo);
                        }
                    }
                }
                
                totalFilesToProcess = categorizedFiles.rendered.length;
                
                // Limit the number of files to process to avoid rate limits
                // Without GitHub token: max 50 files, with token: max 200 files
                const githubToken = document.getElementById('github-token').value.trim();
                const maxFiles = githubToken ? 200 : 50;
                
                if (totalFilesToProcess > maxFiles) {
                    console.warn(`Repository has ${totalFilesToProcess} files to render. Limiting to ${maxFiles} files to avoid rate limits.`);
                    
                    // Sort files by size (smaller first) to prioritize text files
                    categorizedFiles.rendered.sort((a, b) => a.size - b.size);
                    
                    // Move excess files to a new "truncated" category
                    const truncatedFiles = categorizedFiles.rendered.splice(maxFiles);
                    if (!categorizedFiles.truncated) categorizedFiles.truncated = [];
                    categorizedFiles.truncated.push(...truncatedFiles);
                    
                    totalFilesToProcess = categorizedFiles.rendered.length;
                }
                
                if (totalFilesToProcess === 0) {
                    return {
                        repoInfo,
                        files: [],
                        categorizedFiles,
                        allFiles,
                        totalSize: 0,
                        treeStructure: await generateTreeStructure(treeData.tree)
                    };
                }
                
                // Fetch content for rendered files with improved rate limiting
                const files = [];
                let totalSize = 0;
                let consecutiveErrors = 0;
                const maxConsecutiveErrors = 3;
                
                for (let i = 0; i < categorizedFiles.rendered.length; i++) {
                    const fileInfo = categorizedFiles.rendered[i];
                    
                    try {
                        // Add delay before each request, increasing with consecutive errors
                        const baseDelay = 200; // Base delay in ms
                        const errorDelay = consecutiveErrors * 500; // Additional delay per consecutive error
                        await new Promise(resolve => setTimeout(resolve, baseDelay + errorDelay));
                        
                        const contentResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${fileInfo.path}`, { headers });
                        
                        if (contentResponse.ok) {
                            const contentData = await contentResponse.json();
                            const content = atob(contentData.content);
                            
                            const file = {
                                path: fileInfo.path,
                                size: fileInfo.size || content.length,
                                content: content,
                                sha: fileInfo.sha
                            };
                            
                            files.push(file);
                            totalSize += file.size;
                            consecutiveErrors = 0; // Reset error count on success
                            
                        } else if (contentResponse.status === 403) {
                            consecutiveErrors++;
                            console.warn(`Rate limit hit while fetching ${fileInfo.path} (${consecutiveErrors} consecutive errors)`);
                            
                            // Only add to failed files if it's NOT an ignored file that somehow got through
                            const recheck = categorizeFile(fileInfo.path, fileInfo.size);
                            if (recheck.category !== 'ignored') {
                                categorizedFiles.failed.push({
                                    ...fileInfo,
                                    category: { include: false, reason: 'rate_limit', category: 'failed' }
                                });
                            }
                            
                            // If we hit too many consecutive errors, stop processing
                            if (consecutiveErrors >= maxConsecutiveErrors) {
                                console.warn(`Too many consecutive rate limit errors (${consecutiveErrors}). Stopping to prevent further issues.`);
                                break;
                            }
                        } else {
                            consecutiveErrors++;
                            console.warn(`HTTP ${contentResponse.status} while fetching ${fileInfo.path}`);
                            
                            // Only add to failed files if it's NOT an ignored file
                            const recheck = categorizeFile(fileInfo.path, fileInfo.size);
                            if (recheck.category !== 'ignored') {
                                categorizedFiles.failed.push({
                                    ...fileInfo,
                                    category: { include: false, reason: `http_${contentResponse.status}`, category: 'failed' }
                                });
                            }
                        }
                    } catch (error) {
                        consecutiveErrors++;
                        console.warn(`Failed to fetch content for ${fileInfo.path}:`, error);
                        
                        // Only add to failed files if it's NOT an ignored file
                        const recheck = categorizeFile(fileInfo.path, fileInfo.size);
                        if (recheck.category !== 'ignored') {
                            categorizedFiles.failed.push({
                                ...fileInfo,
                                category: { include: false, reason: 'fetch_error', category: 'failed' }
                            });
                        }
                    }
                    
                    processedFiles++;
                    updateProgress(processedFiles, totalFilesToProcess);
                }
                
                // FINAL DEBUG: Check if any ignored files made it to the final results
                console.error('🔍 FINAL FILES COUNT:', files.length);
                const badFiles = files.filter(f => f.path === '.gitattributes' || f.path.endsWith('/.gitattributes'));
                if (badFiles.length > 0) {
                    console.error('🚨 ERROR: .gitattributes found in final results!', badFiles);
                }
                
                return {
                    repoInfo,
                    files,
                    categorizedFiles,
                    allFiles,
                    totalSize,
                    treeStructure: await generateTreeStructure(treeData.tree)
                };
                
            } catch (error) {
                throw error;
            } finally {
                loading.style.display = 'none';
                renderBtn.disabled = false;
            }
        }

        // Render file content with syntax highlighting and overflow handling
        function renderFileContent(content, filename) {
            if (isMarkdownFile(filename)) {
                try {
                    // Process the markdown with our configured marked renderer
                    let html = marked.parse(content);
                    
                    // Post-process for additional GitHub features
                    html = processGitHubFeatures(html, content);
                    
                    return `<div class="markdown-content">${html}</div>`;
                } catch (error) {
                    console.warn('Markdown parsing failed:', error);
                    // Fallback to plain text if markdown parsing fails
                    const escapedContent = content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    return `<pre><code>${escapedContent}</code></pre>`;
                }
            } else {
                try {
                    const highlighted = hljs.highlightAuto(content, [getFileExtension(filename)]);
                    return `<pre class="hljs-container"><code class="hljs">${highlighted.value}</code></pre>`;
                } catch (error) {
                    // Fallback to plain text with proper escaping
                    const escapedContent = content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                    return `<pre><code>${escapedContent}</code></pre>`;
                }
            }
        }

        // Process additional GitHub-specific markdown features
        function processGitHubFeatures(html, originalContent) {
            // Handle @mentions (basic styling)
            html = html.replace(/@([a-zA-Z0-9_-]+)/g, '<span class="mention">@$1</span>');
            
            // Handle issue/PR references like #123
            html = html.replace(/#(\d+)/g, '<span class="issue-reference">#$1</span>');
            
            // Handle commit SHA references (basic 7+ char hex)
            html = html.replace(/\b([a-f0-9]{7,40})\b/g, '<code class="commit-sha">$1</code>');
            
            return html;
        }

        // Generate CXML format for LLM
        function generateCXML(files) {
            let cxml = '<documents>\n';
            
            files.forEach((file, index) => {
                cxml += `<document index="${index + 1}">\n`;
                cxml += `<source>${file.path}</source>\n`;
                cxml += '<document_content>\n';
                cxml += file.content;
                cxml += '\n</document_content>\n';
                cxml += '</document>\n';
            });
            
            cxml += '</documents>';
            return cxml;
        }

        // Generate directory tree structure (only non-ignored files)
        async function generateTreeStructure(treeData) {
            const directories = new Set();
            const files = [];
            
            // Collect all directories and files, but filter out ignored files
            for (const item of treeData) {
                if (item.type === 'tree') {
                    directories.add(item.path);
                } else if (item.type === 'blob') {
                    // Check if this file should be ignored
                    const category = categorizeFile(item.path, item.size || 0);
                    if (category.category !== 'ignored') {
                        files.push(item.path);
                        // Add parent directories
                        const parts = item.path.split('/');
                        for (let i = 1; i < parts.length; i++) {
                            directories.add(parts.slice(0, i).join('/'));
                        }
                    }
                }
            }
            
            // Sort directories and files
            const sortedDirs = Array.from(directories).sort();
            const sortedFiles = files.sort();
            
            // Build tree representation
            const tree = [];
            const processed = new Set();
            
            function addToTree(path, isFile = false) {
                if (processed.has(path)) return;
                processed.add(path);
                
                const parts = path.split('/');
                const depth = parts.length - 1;
                const name = parts[parts.length - 1];
                const prefix = '  '.repeat(depth);
                
                if (depth === 0) {
                    tree.push(`${name}${isFile ? '' : '/'}`);
                } else {
                    tree.push(`${prefix}├── ${name}${isFile ? '' : '/'}`);
                }
            }
            
            // Add directories first
            for (const dir of sortedDirs) {
                addToTree(dir, false);
            }
            
            // Add files
            for (const file of sortedFiles) {
                if (!processed.has(file)) {
                    addToTree(file, true);
                }
            }
            
            return tree.join('\n');
        }

        // Add repository validation
        function validateRepoUrl(url) {
            const githubPattern = /^https?:\/\/(www\.)?github\.com\/[a-zA-Z0-9-_]+\/[a-zA-Z0-9-_.]+\/?(\?.*)?$/;
            return githubPattern.test(url);
        }

        // Main repository rendering function
        async function renderRepository() {
            const repoUrl = document.getElementById('repo-input').value.trim();
            if (!repoUrl) {
                alert('Please enter a GitHub repository URL');
                return;
            }
            
            if (!validateRepoUrl(repoUrl)) {
                alert('Please enter a valid GitHub repository URL (e.g., https://github.com/username/repository)');
                return;
            }
            
            const repoInfo = parseRepoUrl(repoUrl);
            if (!repoInfo) {
                alert('Could not parse repository information from URL');
                return;
            }
            
            try {
                // Check rate limit before starting
                await checkRateLimit();
                
                // Reset progress tracking
                processedFiles = 0;
                totalFilesToProcess = 0;
                
                const result = await fetchRepositoryContents(repoInfo.owner, repoInfo.repo);
                
                if (result.files.length === 0) {
                    alert('No renderable files found in this repository (only binary files or files too large).');
                    return;
                }
                
                repositoryData = result;
                
                // Update UI with results
                updateRepositoryUI();
                
                // Show results
                document.getElementById('results-container').classList.add('show');
                
            } catch (error) {
                const errorMessage = handleApiError(error, 'Repository rendering');
                alert(errorMessage);
            }
        }

        // Handle Enter key in input
        document.addEventListener('DOMContentLoaded', function() {
            const repoInput = document.getElementById('repo-input');
            if (repoInput) {
                repoInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        renderRepository();
                    }
                });
            }
        });

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            try {
                initTheme();
                
                // Set responsive defaults for files per page
                adjustFilesPerPageForScreen();
                
                // Load saved GitHub token
                const savedToken = localStorage.getItem('github-token');
                const tokenInput = document.getElementById('github-token');
                if (savedToken && tokenInput) {
                    tokenInput.value = savedToken;
                }
                
                // Save token when it changes
                if (tokenInput) {
                    tokenInput.addEventListener('input', function() {
                        const token = this.value.trim();
                        if (token) {
                            localStorage.setItem('github-token', token);
                        } else {
                            localStorage.removeItem('github-token');
                        }
                    });
                }
                
                // Mark files per page as manually set when user changes it
                const filesPerPageSelect = document.getElementById('files-per-page-select');
                if (filesPerPageSelect) {
                    filesPerPageSelect.addEventListener('change', function() {
                        this.dataset.manuallySet = 'true';
                    });
                }
            } catch (error) {
                console.error('Error during app initialization:', error);
            }
            
            // Add some example URLs for testing
            const exampleRepos = [
                'https://github.com/karpathy/nanoGPT',
                'https://github.com/facebook/react',
                'https://github.com/microsoft/vscode'
            ];
            
            // You can uncomment this to show example repos
            // console.log('Example repositories you can try:', exampleRepos);
        });

        // Smooth scrolling for anchor links
        document.addEventListener('click', function(e) {
            if (e.target.tagName === 'A' && e.target.getAttribute('href').startsWith('#file-')) {
                e.preventDefault();
                const target = document.querySelector(e.target.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
        });

        // Copy to clipboard functionality for LLM view
        document.addEventListener('DOMContentLoaded', function() {
            const llmTextarea = document.getElementById('llm-textarea');
            if (llmTextarea) {
                llmTextarea.addEventListener('click', function() {
                    this.select();
                });
            }
        });

        // Add keyboard shortcut for copying in LLM view
        document.addEventListener('keydown', function(e) {
            if (currentView === 'llm' && (e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                const textarea = document.getElementById('llm-textarea');
                textarea.focus();
                textarea.select();
            }
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            // Recalculate layout if needed
            const sidebar = document.querySelector('.sidebar');
            if (window.innerWidth <= 768) {
                if (sidebar && sidebar.style.position === 'sticky') {
                    sidebar.style.position = 'static';
                }
            } else {
                if (sidebar && sidebar.style.position === 'static') {
                    sidebar.style.position = 'sticky';
                }
            }
            
            // Update pagination for new screen size
            if (repositoryData && repositoryData.files) {
                updatePagination();
            }
        });

        // Show/hide footer based on scroll position
        let footerTimeout;
        window.addEventListener('scroll', function() {
            const footer = document.querySelector('.footer');
            if (!footer) return;
            
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;
            
            // Show footer when user scrolls to within 200px of the bottom
            const nearBottom = scrollTop + windowHeight >= documentHeight - 200;
            
            if (nearBottom) {
                footer.classList.add('show');
                // Hide footer after 3 seconds of no scrolling
                clearTimeout(footerTimeout);
                footerTimeout = setTimeout(() => {
                    footer.classList.remove('show');
                }, 3000);
            } else {
                footer.classList.remove('show');
                clearTimeout(footerTimeout);
            }
        });

        // Add keyboard navigation for pagination
        document.addEventListener('keydown', function(e) {
            if (currentView === 'human' && repositoryData && totalPages > 1) {
                if (e.key === 'ArrowLeft' && currentPage > 1) {
                    e.preventDefault();
                    goToPage(currentPage - 1);
                } else if (e.key === 'ArrowRight' && currentPage < totalPages) {
                    e.preventDefault();
                    goToPage(currentPage + 1);
                }
            }
            
            // Existing LLM view keyboard shortcut
            if (currentView === 'llm' && (e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                const textarea = document.getElementById('llm-textarea');
                textarea.focus();
                textarea.select();
            }
        });

        // Progress tracking for large repositories
        let processedFiles = 0;
        let totalFilesToProcess = 0;

        function updateProgress(current, total) {
            if (total > 10) { // Only show progress for larger repos
                const percent = Math.round((current / total) * 100);
                const loadingText = document.querySelector('.loading span');
                if (loadingText) {
                    loadingText.textContent = `Processing repository... ${percent}% (${current}/${total} files)`;
                }
            }
        }

        // Enhanced UI update with categorized files and tree view
        function updateRepositoryUI() {
            if (!repositoryData) return;
            
            // Update repo info with enhanced statistics
            const repoInfoElement = document.getElementById('repo-info');
            const repoNameElement = document.getElementById('repo-name');
            const repoDescElement = document.getElementById('repo-description');
            
            if (repoNameElement && repositoryData.repoInfo) {
                repoNameElement.innerHTML = `
                    <a href="${repositoryData.repoInfo.html_url}" target="_blank" style="color: var(--accent-primary); text-decoration: none;">
                        ${repositoryData.repoInfo.full_name}
                    </a>
                `;
            }
            
            if (repoDescElement && repositoryData.repoInfo) {
                repoDescElement.textContent = repositoryData.repoInfo.description || 'No description available';
            }
            
            // Enhanced statistics
            const totalFiles = repositoryData.allFiles ? repositoryData.allFiles.length : 0;
            const renderedCount = repositoryData.files ? repositoryData.files.length : 0;
            const skippedCount = totalFiles - renderedCount;
            
            const fileCountElement = document.getElementById('file-count');
            const totalSizeElement = document.getElementById('total-size');
            const mainLanguageElement = document.getElementById('main-language');
            
            if (fileCountElement) {
                fileCountElement.textContent = `${renderedCount}/${totalFiles}`;
            }
            if (totalSizeElement) {
                totalSizeElement.textContent = formatBytes(repositoryData.totalSize || 0);
            }
            if (mainLanguageElement && repositoryData.repoInfo) {
                mainLanguageElement.textContent = repositoryData.repoInfo.language || 'Mixed';
            }
            
            // Add additional stats
            const statsContainer = document.querySelector('.repo-stats');
            if (statsContainer && repositoryData.repoInfo) {
                statsContainer.innerHTML = `
                    <span class="stat">Files: <strong>${renderedCount}/${totalFiles}</strong></span>
                    <span class="stat">Size: <strong>${formatBytes(repositoryData.totalSize || 0)}</strong></span>
                    <span class="stat">Language: <strong>${repositoryData.repoInfo.language || 'Mixed'}</strong></span>
                    <span class="stat">Skipped: <strong>${skippedCount}</strong></span>
                `;
            }
            
            if (repoInfoElement) {
                repoInfoElement.style.display = 'block';
            }
            
            // Generate enhanced file tree with directory structure
            generateEnhancedFileTree();
            
            // Generate file sections with improved navigation
            generateEnhancedFileSections();
            
            // Add directory tree view
            addDirectoryTreeView();
            
            // Add skipped files summary
            addSkippedFilesSummary();
            
            // Generate CXML for LLM view
            if (repositoryData.files) {
                const cxml = generateCXML(repositoryData.files);
                const llmTextarea = document.getElementById('llm-textarea');
                if (llmTextarea) {
                    llmTextarea.value = cxml;
                }
            }
        }

        // Generate file tree with better organization
        function generateFileTree() {
            const fileTree = document.getElementById('file-tree');
            fileTree.innerHTML = '';
            
            // Sort files by directory structure
            const sortedFiles = [...repositoryData.files].sort((a, b) => {
                const aDirs = a.path.split('/').length;
                const bDirs = b.path.split('/').length;
                if (aDirs !== bDirs) return aDirs - bDirs;
                return a.path.localeCompare(b.path);
            });
            
            sortedFiles.forEach(file => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                a.href = `#file-${fileId}`;
                a.textContent = file.path;
                a.title = `${file.path} (${formatBytes(file.size)})`;
                li.appendChild(a);
                
                // Add file size indicator
                const sizeSpan = document.createElement('span');
                sizeSpan.className = 'file-size';
                sizeSpan.textContent = ` (${formatBytes(file.size)})`;
                sizeSpan.style.color = 'var(--text-muted)';
                sizeSpan.style.fontSize = '0.8em';
                li.appendChild(sizeSpan);
                
                fileTree.appendChild(li);
            });
        }

        // Generate file sections with better formatting
        function generateFileSections() {
            const filesContainer = document.getElementById('files-container');
            filesContainer.innerHTML = '';
            
            repositoryData.files.forEach((file, index) => {
                const section = document.createElement('div');
                section.className = 'file-section';
                const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                section.id = `file-${fileId}`;
                
                const header = document.createElement('div');
                header.className = 'file-header';
                header.innerHTML = `
                    <h3>${file.path}</h3>
                    <span class="file-size">${formatBytes(file.size)} • ${index + 1} of ${repositoryData.files.length}</span>
                `;
                
                const content = document.createElement('div');
                content.className = 'file-content';
                
                try {
                    content.innerHTML = renderFileContent(file.content, file.path);
                } catch (error) {
                    content.innerHTML = `<pre class="error">Error rendering file: ${error.message}</pre>`;
                }
                
                section.appendChild(header);
                section.appendChild(content);
                filesContainer.appendChild(section);
            });
        }

        // Enhanced error handling
        function handleApiError(error, context) {
            console.error(`${context}:`, error);
            
            if (error.message.includes('API rate limit')) {
                const token = document.getElementById('github-token').value.trim();
                if (!token) {
                    return 'GitHub API rate limit exceeded. Please add a GitHub Personal Access Token to continue. You can create one at https://github.com/settings/tokens with "public_repo" scope.';
                } else {
                    return error.message;
                }
            } else if (error.message.includes('Invalid GitHub token')) {
                return 'Invalid GitHub token. Please check your token and try again. Make sure it has "public_repo" scope.';
            } else if (error.message.includes('not found')) {
                return 'Repository not found. Please check the URL and make sure the repository is public.';
            } else if (error.message.includes('network')) {
                return 'Network error. Please check your internet connection.';
            } else {
                return `Error: ${error.message}`;
            }
        }

        // Enhanced file tree with directory grouping
        function generateEnhancedFileTree() {
            const fileTree = document.getElementById('file-tree');
            if (!fileTree || !repositoryData || !repositoryData.files) return;
            
            // Update the sidebar header to show file count
            const sidebarHeader = fileTree.parentElement.querySelector('h3');
            if (sidebarHeader) {
                sidebarHeader.innerHTML = `Files (${repositoryData.files.length}) <small style="color: var(--text-muted); font-weight: normal;">↕️ scroll</small>`;
            }
            
            fileTree.innerHTML = '';
            
            // Add "Back to top" link
            const backToTop = document.createElement('li');
            backToTop.innerHTML = '<a href="#top" style="color: var(--accent-primary); font-weight: bold;">↑ Back to top</a>';
            fileTree.appendChild(backToTop);
            
            // Group files by directory
            const filesByDir = {};
            repositoryData.files.forEach(file => {
                const parts = file.path.split('/');
                const dir = parts.length > 1 ? parts.slice(0, -1).join('/') : '';
                const filename = parts[parts.length - 1];
                
                if (!filesByDir[dir]) {
                    filesByDir[dir] = [];
                }
                filesByDir[dir].push({ ...file, filename });
            });
            
            // Sort directories
            const sortedDirs = Object.keys(filesByDir).sort((a, b) => {
                if (a === '') return -1; // Root files first
                if (b === '') return 1;
                return a.localeCompare(b);
            });
            
            sortedDirs.forEach(dir => {
                // Add directory header if not root
                if (dir !== '') {
                    const dirLi = document.createElement('li');
                    dirLi.style.fontWeight = 'bold';
                    dirLi.style.color = 'var(--text-secondary)';
                    dirLi.style.marginTop = '0.5rem';
                    dirLi.textContent = `📁 ${dir}/`;
                    fileTree.appendChild(dirLi);
                }
                
                // Add files in directory
                filesByDir[dir].sort((a, b) => a.filename.localeCompare(b.filename)).forEach(file => {
                    const li = document.createElement('li');
                    li.style.paddingLeft = dir === '' ? '0' : '1rem';
                    
                    const a = document.createElement('a');
                    const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                    a.href = `#file-${fileId}`;
                    a.textContent = file.filename;
                    a.title = `${file.path} (${formatBytes(file.size)})`;
                    li.appendChild(a);
                    
                    // Add file size indicator
                    const sizeSpan = document.createElement('span');
                    sizeSpan.className = 'file-size';
                    sizeSpan.textContent = ` (${formatBytes(file.size)})`;
                    sizeSpan.style.color = 'var(--text-muted)';
                    sizeSpan.style.fontSize = '0.8em';
                    li.appendChild(sizeSpan);
                    
                    fileTree.appendChild(li);
                });
            });
        }

        // Enhanced file sections with better navigation and pagination
        function generateEnhancedFileSections() {
            const filesContainer = document.getElementById('files-container');
            if (!filesContainer) return;
            
            filesContainer.innerHTML = '';
            
            if (!repositoryData || !repositoryData.files) return;
            
            // Calculate pagination
            const totalFiles = repositoryData.files.length;
            const startIndex = (currentPage - 1) * filesPerPage;
            const endIndex = Math.min(startIndex + filesPerPage, totalFiles);
            const filesToShow = repositoryData.files.slice(startIndex, endIndex);
            
            filesToShow.forEach((file, index) => {
                const globalIndex = startIndex + index; // Global index across all files
                const section = document.createElement('div');
                section.className = 'file-section';
                const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                section.id = `file-${fileId}`;
                
                const header = document.createElement('div');
                header.className = 'file-header';
                header.innerHTML = `
                    <h3>
                        <span style="color: var(--text-muted);">${globalIndex + 1}.</span>
                        ${file.path}
                    </h3>
                    <span class="file-size">
                        ${formatBytes(file.size)} • 
                        ${getFileExtension(file.path).toUpperCase() || 'TXT'} • 
                        ${globalIndex + 1} of ${totalFiles}
                    </span>
                `;
                
                const content = document.createElement('div');
                content.className = 'file-content';
                
                try {
                    content.innerHTML = renderFileContent(file.content, file.path);
                } catch (error) {
                    content.innerHTML = `<pre class="error">Error rendering file: ${error.message}</pre>`;
                }
                
                // Add back to top link
                const backToTop = document.createElement('div');
                backToTop.className = 'back-top';
                backToTop.innerHTML = '<a href="#top" style="color: var(--accent-primary); text-decoration: none;">↑ Back to top</a>';
                backToTop.style.textAlign = 'right';
                backToTop.style.marginTop = '1rem';
                backToTop.style.padding = '0.5rem 0';
                backToTop.style.borderTop = '1px solid var(--border-secondary)';
                backToTop.style.fontSize = '0.9rem';
                
                section.appendChild(header);
                section.appendChild(content);
                section.appendChild(backToTop);
                filesContainer.appendChild(section);
            });
            
            // Update pagination after generating sections
            updatePagination();
        }

        // Add directory tree view
        function addDirectoryTreeView() {
            if (!repositoryData.treeStructure) return;
            
            // Find the sidebar and add tree view before file list
            const sidebar = document.querySelector('.sidebar');
            const existingTree = document.getElementById('directory-tree');
            if (existingTree) {
                existingTree.remove();
            }
            
            const treeSection = document.createElement('div');
            treeSection.id = 'directory-tree';
            treeSection.innerHTML = `
                <h3 style="margin-bottom: 1rem; color: var(--text-primary); font-size: 1rem;">
                    📁 Directory Structure
                </h3>
                <pre style="
                    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
                    font-size: 0.8rem;
                    line-height: 1.2;
                    color: var(--text-secondary);
                    background: var(--bg-primary);
                    border: 1px solid var(--border-secondary);
                    border-radius: 4px;
                    padding: 0.75rem;
                    margin-bottom: 1.5rem;
                    overflow-x: auto;
                    max-height: 200px;
                    overflow-y: auto;
                ">${repositoryData.treeStructure}</pre>
            `;
            
            // Insert before the file list
            const fileTreeContainer = document.querySelector('.sidebar h3');
            if (fileTreeContainer) {
                sidebar.insertBefore(treeSection, fileTreeContainer);
            }
        }

        // Add skipped files summary
        function addSkippedFilesSummary() {
            if (!repositoryData.categorizedFiles) return;
            
            const { binary, large, ignored, failed, truncated } = repositoryData.categorizedFiles;
            // Don't count ignored files in the summary - they should be completely hidden
            const totalSkipped = binary.length + large.length + (failed ? failed.length : 0) + (truncated ? truncated.length : 0);
            
            if (totalSkipped === 0) return;
            
            // Find where to insert the summary (after repo info)
            const repoInfo = document.getElementById('repo-info');
            let summaryElement = document.getElementById('skipped-summary');
            
            if (!summaryElement) {
                summaryElement = document.createElement('div');
                summaryElement.id = 'skipped-summary';
                summaryElement.className = 'skipped-summary';
                summaryElement.style.cssText = `
                    background-color: var(--bg-secondary);
                    border: 1px solid var(--border-primary);
                    border-radius: 8px;
                    padding: 1rem;
                    margin-top: 1rem;
                `;
                repoInfo.parentNode.insertBefore(summaryElement, repoInfo.nextSibling);
            }
            
            let summaryHTML = `
                <h3 style="margin: 0 0 1rem 0; color: var(--text-primary); font-size: 1rem;">
                    📊 Skipped Files Summary (${totalSkipped})
                </h3>
            `;
            
            if (binary.length > 0) {
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            🔒 Binary files (${binary.length})
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${binary.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                            ${binary.length > 10 ? `<li><em>... and ${binary.length - 10} more</em></li>` : ''}
                        </ul>
                    </details>
                `;
            }
            
            if (large.length > 0) {
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            📦 Large files (${large.length})
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${large.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                            ${large.length > 10 ? `<li><em>... and ${large.length - 10} more</em></li>` : ''}
                        </ul>
                    </details>
                `;
            }
            
            if (ignored.length > 0) {
                // Ignored files are completely hidden - don't show them in summary
                // summaryHTML += `
                //     <details style="margin-bottom: 0.5rem;">
                //         <summary style="cursor: pointer; color: var(--text-secondary);">
                //             🙈 Git/ignored files (${ignored.length})
                //         </summary>
                //         <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                //             ${ignored.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                //             ${ignored.length > 10 ? `<li><em>... and ${ignored.length - 10} more</em></li>` : ''}
                //         </ul>
                //     </details>
                // `;
            }
            
            if (failed && failed.length > 0) {
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            ⚠️ Failed to fetch (${failed.length}) - Rate limit or API errors
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${failed.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)}) - ${f.category.reason}</li>`).join('')}
                            ${failed.length > 10 ? `<li><em>... and ${failed.length - 10} more</em></li>` : ''}
                        </ul>
                        <p style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.8rem; font-style: italic;">
                            💡 These files are likely text files but couldn't be fetched due to API rate limits or network errors. Try again later or add a GitHub token.
                        </p>
                    </details>
                `;
            }
            
            if (truncated && truncated.length > 0) {
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            ✂️ Truncated files (${truncated.length}) - Limited to prevent rate limits
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${truncated.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                            ${truncated.length > 10 ? `<li><em>... and ${truncated.length - 10} more</em></li>` : ''}
                        </ul>
                        <p style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.8rem; font-style: italic;">
                            💡 Too many files to process without hitting rate limits. Add a GitHub token to process up to 200 files instead of 50.
                        </p>
                    </details>
                `;
            }
            
            summaryElement.innerHTML = summaryHTML;
        }
    </script>
</body>
</html>