<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Render - GitHub Repository Viewer | Browse and Explore Code Online</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Git Render is a powerful web tool to view, browse, and explore GitHub repositories online. Render repository files with syntax highlighting, markdown support, and LLM-friendly output formats.">
    <meta name="keywords" content="github, repository viewer, code browser, git, markdown renderer, syntax highlighting, code exploration, developer tools, github viewer, repository browser">
    <meta name="author" content="Mohamed Elashri">
    <meta name="robots" content="index, follow">
    <meta name="language" content="en">
    <meta name="revisit-after" content="7 days">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://melashri.net/grender">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://melashri.net/grender">
    <meta property="og:title" content="Git Render - GitHub Repository Viewer">
    <meta property="og:description" content="Browse and explore GitHub repositories online with syntax highlighting, markdown rendering, and developer-friendly features.">
    <meta property="og:image" content="https://melashri.net/grender/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Git Render - GitHub Repository Viewer Interface">
    <meta property="og:site_name" content="Git Render">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://melashri.net/grender">
    <meta property="twitter:title" content="Git Render - GitHub Repository Viewer">
    <meta property="twitter:description" content="Browse and explore GitHub repositories online with syntax highlighting, markdown rendering, and developer-friendly features.">
    <meta property="twitter:image" content="https://melashri.net/grender/og-image.png">
    <meta property="twitter:image:alt" content="Git Render - GitHub Repository Viewer Interface">
    <meta property="twitter:creator" content="@MohamedElashri">
    <meta property="twitter:site" content="@MohamedElashri">
    
    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#0969da">
    <meta name="msapplication-TileColor" content="#0969da">
    <meta name="application-name" content="Git Render">
    <meta name="apple-mobile-web-app-title" content="Git Render">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <!-- Preconnect to external domains for performance -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://api.github.com">
    <link rel="dns-prefetch" href="https://github.com">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Git Render",
        "description": "A web tool to view, browse, and explore GitHub repositories online with syntax highlighting and markdown support.",
        "url": "https://melashri.net/grender",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Web Browser",
        "creator": {
            "@type": "Person",
            "name": "Mohamed Elashri",
            "url": "https://melashri.net"
        },
        "datePublished": "2024-12-21",
        "dateModified": "2025-08-26",
        "browserRequirements": "Requires JavaScript",
        "softwareVersion": "1.0",
        "screenshot": "https://melashri.net/grender/screenshot.png",
        "featureList": [
            "GitHub repository browsing",
            "Syntax highlighting", 
            "Markdown rendering",
            "LLM-friendly output formats",
            "Dark/Light theme support",
            "File tree navigation",
            "Search functionality"
        ]
    }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="highlight-light">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="highlight-dark" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #ffffff;
            --text-primary: #24292f;
            --text-secondary: #656d76;
            --text-muted: #8b949e;
            --border-primary: #d1d9e0;
            --border-secondary: #eaeef2;
            --accent-primary: #0969da;
            --accent-hover: #0860ca;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #7d8590;
            --text-muted: #656d76;
            --border-primary: #30363d;
            --border-secondary: #21262d;
            --accent-primary: #2f81f7;
            --accent-hover: #1f6feb;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-primary);
            text-decoration: none;
            cursor: pointer;
        }

        .logo:hover {
            color: var(--accent-hover);
        }

        .theme-toggle {
            background: none;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 0.5rem;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }

        .theme-toggle:hover {
            background-color: var(--bg-tertiary);
            transform: scale(1.05);
        }

        /* Main Content */
        .main-content {
            margin-top: 80px;
            margin-bottom: 80px;
            min-height: calc(100vh - 160px);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .intro-section {
            text-align: center;
            padding: 3rem 0;
        }

        .intro-section h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .intro-section p {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Input Section */
        .input-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .repo-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
        }

        .repo-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.1);
        }

        /* Highlight file limit input when it has a custom value */
        .repo-input[type="number"]:not(:placeholder-shown) {
            border-color: var(--accent-primary);
            background-color: rgba(9, 105, 218, 0.05);
        }

        .render-btn {
            padding: 0.75rem 1.5rem;
            background-color: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .render-btn:hover:not(:disabled) {
            background-color: var(--accent-hover);
            transform: translateY(-1px);
        }

        .render-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
        }

        .toggle-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .toggle-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .toggle-btn:hover:not(.active) {
            background: var(--bg-tertiary);
        }

        /* Results */
        .results-container {
            margin-top: 2rem;
            display: none;
        }

        .results-container.show {
            display: block;
        }

        .repo-info {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .repo-info h3 {
            margin-bottom: 0.5rem;
            color: var(--accent-primary);
        }

        .repo-stats {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .stat {
            color: var(--text-secondary);
        }

        /* Sidebar */
        .content-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            margin-top: 1rem;
            min-width: 0; /* Allow grid items to shrink below content size */
        }

        .sidebar {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1rem;
            padding-bottom: 80px; /* Extra padding to ensure footer doesn't block content */
            max-height: calc(100vh - 120px); /* Limit height to viewport minus header space */
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: hidden; /* Hide horizontal scroll */
            position: sticky;
            top: 100px;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .files-container {
            min-width: 0; /* Allow container to shrink */
            overflow-x: hidden; /* Prevent horizontal overflow */
        }

        .sidebar h3 {
            margin-bottom: 1rem;
            margin-top: 0;
            color: var(--text-primary);
            font-size: 1rem;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .file-tree {
            list-style: none;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 0;
            padding: 0;
            height: auto; /* Ensure the tree can expand to full height */
            flex-grow: 1; /* Allow it to take available space */
        }

        .file-tree li {
            padding: 0.2rem 0;
            word-wrap: break-word; /* Handle long filenames */
        }

        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border-primary);
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .file-tree a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .file-tree a:hover {
            text-decoration: underline;
        }

        /* File sections */
        .file-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden;
            min-width: 0; /* Allow sections to shrink */
            max-width: 100%; /* Prevent overflow */
        }

        .file-header {
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-header h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .file-size {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .file-content {
            padding: 0;
            overflow-x: auto;
            max-width: 100%;
        }

        /* Add padding for markdown content specifically */
        .file-content .markdown-content {
            padding: 1rem 1.5rem;
        }

        /* Add minimal padding for non-code content */
        .file-content > *:not(.hljs-container):not(pre):not(.code-block-wrapper) {
            padding-left: 1rem;
            padding-right: 1rem;
        }

        .file-content pre {
            margin: 0;
            padding: 1rem;
            overflow-x: auto;
            background: transparent;
            font-size: 0.9rem;
            line-height: 1.4;
            max-width: 100%;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .file-content code {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            word-wrap: break-word;
            white-space: pre-wrap;
            display: block;
            overflow-x: auto;
        }

        /* Ensure code blocks don't overflow */
        .hljs {
            overflow-x: auto !important;
            max-width: 100% !important;
            word-wrap: break-word !important;
            white-space: pre-wrap !important;
        }

        .hljs-container {
            overflow-x: auto;
            max-width: 100%;
            background: var(--bg-tertiary);
            border-radius: 0 0 6px 6px;
            margin: 0;
        }

        /* Code block wrappers with language headers */
        .code-block-wrapper {
            margin: 1rem 0;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-secondary);
        }

        .code-block-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            border-radius: 6px 6px 0 0;
        }

        .code-language {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-weight: 500;
            text-transform: lowercase;
        }

        .code-block-wrapper .hljs-container {
            border-radius: 0 0 6px 6px;
            border: none;
            margin: 0;
        }

        /* Better handling of long lines in code */
        .file-content .hljs {
            tab-size: 4;
            -moz-tab-size: 4;
        }

        /* Ensure proper line breaking for long URLs and strings */
        .hljs .hljs-string,
        .hljs .hljs-comment {
            word-break: break-word;
            white-space: pre-wrap;
        }

        /* GitHub Flavored Markdown Styles */
        .file-content h1, .file-content h2, .file-content h3, 
        .file-content h4, .file-content h5, .file-content h6 {
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            line-height: 1.25;
            color: var(--text-primary);
            border-bottom: none;
        }

        .file-content h1 {
            font-size: 2rem;
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 0.5rem;
        }

        .file-content h2 {
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border-secondary);
            padding-bottom: 0.3rem;
        }

        .file-content h3 { font-size: 1.25rem; }
        .file-content h4 { font-size: 1rem; }
        .file-content h5 { font-size: 0.875rem; }
        .file-content h6 { font-size: 0.85rem; color: var(--text-secondary); }

        .file-content p {
            margin: 0 0 1rem 0;
            line-height: 1.6;
        }

        .file-content blockquote {
            margin: 0 0 1rem 0;
            padding: 0 1rem;
            color: var(--text-secondary);
            border-left: 4px solid var(--border-primary);
            background-color: var(--bg-secondary);
        }

        .file-content ul, .file-content ol {
            margin: 0 0 1rem 0;
            padding-left: 2rem;
        }

        .file-content li {
            margin: 0.25rem 0;
            line-height: 1.6;
        }

        /* Task List Styles */
        .file-content .task-list-item {
            list-style: none;
            margin-left: -1.5rem;
        }

        .file-content .task-list-item-checkbox {
            margin-right: 0.5rem;
            margin-left: 0;
        }

        /* Table Styles */
        .table-wrapper {
            overflow-x: auto;
            margin: 1rem 0;
        }

        .markdown-table {
            border-collapse: collapse;
            border-spacing: 0;
            width: 100%;
            max-width: 100%;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-primary);
        }

        .markdown-table th,
        .markdown-table td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid var(--border-primary);
            line-height: 1.6;
        }

        .markdown-table th {
            background-color: var(--bg-secondary);
            font-weight: 600;
            color: var(--text-primary);
        }

        .markdown-table tr:nth-child(even) {
            background-color: var(--bg-secondary);
        }

        .markdown-table tr:hover {
            background-color: var(--bg-tertiary);
        }

        /* Inline Code */
        .file-content code:not(.hljs) {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }

        /* Horizontal Rules */
        .file-content hr {
            border: none;
            border-top: 1px solid var(--border-primary);
            margin: 2rem 0;
        }

        /* Images */
        .file-content img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 1rem 0;
        }

        /* Links */
        .file-content a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .file-content a:hover {
            text-decoration: underline;
        }

        /* Emphasis */
        .file-content strong {
            font-weight: 600;
            color: var(--text-primary);
        }

        .file-content em {
            font-style: italic;
        }

        /* GitHub-specific features */
        .markdown-content {
            line-height: 1.6;
            /* Padding is handled by .file-content .markdown-content rule above */
        }

        /* Jupyter Notebook specific styles */
        .jupyter-notebook {
            position: relative;
        }

        .notebook-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }

        .jupyter-notebook .code-block-wrapper {
            position: relative;
        }

        .jupyter-notebook .code-block-wrapper::before {
            content: "📱 Cell";
            position: absolute;
            top: 0.5rem;
            right: 1rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            z-index: 1;
        }

        .jupyter-notebook code:not(.hljs) {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
        }

        .jupyter-notebook blockquote {
            border-left-color: #ff6b35;
            background-color: rgba(255, 107, 53, 0.1);
        }

        .jupyter-notebook h1, .jupyter-notebook h2, .jupyter-notebook h3 {
            border-bottom-color: var(--border-secondary);
        }

        .mention {
            color: var(--accent-primary);
            font-weight: 500;
        }

        .issue-reference {
            color: var(--accent-primary);
            font-weight: 500;
        }

        .commit-sha {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.9em;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }

        /* Better spacing for markdown content */
        .markdown-content > *:first-child {
            margin-top: 0;
        }

        .markdown-content > *:last-child {
            margin-bottom: 0;
        }

        /* LLM View */
        .llm-view {
            display: none;
        }

        .llm-view.show {
            display: block;
        }

        .llm-textarea {
            width: 100%;
            height: 60vh;
            padding: 1rem;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            resize: vertical;
        }

        .copy-hint {
            margin-top: 0.5rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            color: var(--text-secondary);
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-primary);
            border-top: 2px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Footer - hidden by default, shown when scrolling near bottom */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border-primary);
            padding: 1rem 2rem;
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
            transform: translateY(100%); /* Hidden by default */
            transition: transform 0.3s ease-in-out;
            z-index: 100;
        }
        
        .footer.show {
            transform: translateY(0); /* Show when near bottom */
        }

        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
            margin-left: 0.5rem;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .github-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 0.5rem;
            vertical-align: text-bottom;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }

            .container {
                padding: 1rem;
                max-width: 100%;
                overflow-x: hidden;
            }

            .input-group {
                flex-direction: column;
            }

            .content-layout {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .sidebar {
                position: static;
                max-height: 300px; /* Limit height on mobile */
                overflow-y: auto; /* Enable vertical scrolling on mobile */
                overflow-x: hidden; /* Hide horizontal scroll on mobile */
            }

            .intro-section h1 {
                font-size: 2rem;
            }

            .repo-stats {
                gap: 1rem;
                flex-direction: column;
            }

            .pagination {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.25rem;
            }

            .pagination button {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
                min-width: 35px;
            }

            .file-content pre {
                font-size: 0.8rem;
                padding: 0.75rem;
                overflow-x: auto;
                white-space: pre;
                word-wrap: normal;
            }

            .file-content code {
                white-space: pre;
                word-wrap: normal;
            }

            /* Reduce padding on mobile for better space utilization */
            .file-content .markdown-content {
                padding: 0.75rem 1rem;
            }

            .file-content > *:not(.hljs-container):not(pre):not(.code-block-wrapper) {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }

            .files-container {
                overflow-x: hidden;
                max-width: 100%;
            }

            .file-section {
                max-width: 100%;
                overflow-x: hidden;
            }
        }

        /* Tablet styles */
        @media (min-width: 769px) and (max-width: 1024px) {
            .content-layout {
                grid-template-columns: 250px 1fr;
                gap: 1.5rem;
            }

            .container {
                padding: 1.5rem;
                max-width: 100%;
            }

            .sidebar {
                font-size: 0.85rem;
                max-height: 400px; /* Limit height on tablet */
                overflow-y: auto; /* Enable vertical scrolling on tablet */
                overflow-x: hidden; /* Hide horizontal scroll on tablet */
            }

            .pagination button {
                padding: 0.6rem 1rem;
            }

            .file-content pre {
                overflow-x: auto;
            }

            .files-container {
                min-width: 0;
                overflow-x: hidden;
            }
        }

        /* Large desktop styles */
        @media (min-width: 1400px) {
            .container {
                max-width: 1400px;
            }

            .content-layout {
                grid-template-columns: 350px 1fr;
                gap: 2.5rem;
            }
        }

        /* Pagination styles */
        .pagination-container {
            margin: 2rem 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        /* Top pagination has less margin */
        #pagination-container-top {
            margin: 1rem 0 2rem 0;
        }

        .pagination-info {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .pagination {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .pagination button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            min-width: 40px;
        }

        .pagination button:hover:not(:disabled) {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination button.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .pagination .ellipsis {
            padding: 0.5rem;
            color: var(--text-muted);
        }

        /* Files per page selector */
        .files-per-page {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .files-per-page label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .files-per-page select {
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        /* Branch/Tag Navigation Styles */
        .branch-controls {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            display: none;
        }

        .branch-controls.show {
            display: block;
        }

        .branch-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }

        .branch-selector label {
            color: var(--text-secondary);
            font-weight: 500;
            min-width: 80px;
        }

        .branch-selector select {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
            min-width: 200px;
            cursor: pointer;
        }

        .branch-selector select:focus {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        .commit-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        .commit-sha-link {
            color: var(--accent-primary);
            text-decoration: none;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }

        .commit-sha-link:hover {
            text-decoration: underline;
        }

        /* Search & Filter Styles */
        .search-controls {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            display: none;
        }

        .search-controls.show {
            display: block;
        }

        .search-input-group {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
            min-width: 200px;
        }

        .search-input:focus {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        .search-btn {
            padding: 0.75rem 1.5rem;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .search-btn:hover:not(:disabled) {
            background: var(--accent-secondary);
            transform: translateY(-1px);
        }

        .search-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .search-filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }

        .search-filters label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .search-filters input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-primary);
            border-radius: 3px;
            background: var(--bg-primary);
            cursor: pointer;
            position: relative;
        }

        .search-filters input[type="checkbox"]:checked {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .search-filters input[type="checkbox"]:checked::after {
            content: '✓';
            color: white;
            font-size: 12px;
            position: absolute;
            top: -2px;
            left: 2px;
        }

        .search-options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .search-options label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .search-results {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-secondary);
        }

        .search-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .search-results-count {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .clear-search-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .clear-search-btn:hover {
            background: var(--bg-tertiary);
        }

        .search-result-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            transition: all 0.2s ease;
        }

        .search-result-item:hover {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }

        .search-result-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .search-result-file {
            color: var(--accent-primary);
            text-decoration: none;
            font-weight: 500;
        }

        .search-result-matches {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .search-result-preview {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.85rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 0.75rem;
            line-height: 1.4;
            overflow-x: auto;
        }

        .search-highlight {
            background: rgba(255, 255, 0, 0.3);
            color: var(--text-primary);
            font-weight: bold;
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
        }

        /* File type filter badges */
        .file-type-filters {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            flex-wrap: wrap;
        }

        .file-type-badge {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .file-type-badge:hover {
            background: var(--bg-secondary);
        }

        .file-type-badge.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        /* Advanced controls toggle */
        .advanced-controls-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
        }

        .toggle-advanced-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .toggle-advanced-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .toggle-advanced-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="#" class="logo" onclick="refreshApp()">Git Render</a>
        <button class="theme-toggle" onclick="toggleTheme()" id="theme-btn">🌙</button>
    </header>

    <main class="main-content">
        <div class="container">
            <section class="intro-section">
                <h1>Git Render - GitHub Repository Viewer</h1>
                <p>Transform any GitHub repository into a single, searchable HTML page with syntax highlighting and markdown rendering. Perfect for code review, exploration, and LLM analysis. Browse repositories with ease using our powerful developer tools.</p>
            </section>

            <section class="input-section">
                <div class="input-group">
                    <input type="text" 
                           class="repo-input" 
                           id="repo-input" 
                           placeholder="https://github.com/username/repository" 
                           value="">
                    <button class="render-btn" onclick="renderRepository()" id="render-btn">
                        Render Repository
                    </button>
                </div>
                <div class="input-group" style="margin-top: 1rem;">
                    <input type="password" 
                           class="repo-input" 
                           id="github-token" 
                           placeholder="GitHub Personal Access Token (optional - helps avoid rate limits)" 
                           value="">
                    <button class="toggle-btn" onclick="toggleTokenVisibility()" id="token-toggle" style="min-width: 120px;">
                        👁️ Show Token
                    </button>
                </div>
                <div class="input-group" style="margin-top: 1rem;">
                    <input type="number" 
                           class="repo-input" 
                           id="file-limit" 
                           placeholder="Max files to process (default: 50 without token, 200 with token)" 
                           min="1" 
                           max="1000"
                           value=""
                           style="flex: 1;">
                    <button class="toggle-btn" onclick="resetFileLimit()" id="reset-limit-btn" style="min-width: 80px;">
                        🔄 Reset
                    </button>
                    <button class="toggle-btn" onclick="showFileLimitInfo()" id="limit-info-btn" style="min-width: 60px;">
                        ℹ️ Info
                    </button>
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
                    💡 <strong>Tip:</strong> Add a GitHub token to avoid rate limits. 
                    <a href="https://github.com/settings/tokens" target="_blank" style="color: var(--accent-primary);">Create one here</a> 
                    with 'public_repo' scope.
                </div>
                <div id="file-limit-info" style="display: none; margin-top: 0.5rem; padding: 1rem; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: 6px; font-size: 0.9rem; color: var(--text-secondary);">
                    <div style="margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">📁 File Limit Information</div>
                    <div style="margin-bottom: 0.5rem;">
                        • <strong>Without GitHub token:</strong> Default limit is 50 files (to stay within anonymous API limits)
                    </div>
                    <div style="margin-bottom: 0.5rem;">
                        • <strong>With GitHub token:</strong> Default limit is 200 files (higher rate limits available)
                    </div>
                    <div style="margin-bottom: 0.5rem;">
                        • <strong>Custom limit:</strong> You can set any limit from 1 to 2000 files
                    </div>
                    <div style="margin-bottom: 0.5rem;">
                        • Files are prioritized by size (smaller files first) to maximize content quality
                    </div>
                    <div style="color: var(--text-muted);">
                        ⚠️ Higher limits may take longer to process and consume more API requests
                    </div>
                </div>
                <div id="loading" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Processing repository...</span>
                </div>
            </section>

            <div class="results-container" id="results-container">
                <div class="view-toggle">
                    <button class="toggle-btn active" onclick="showView('human')" id="human-btn">👤 Human View</button>
                    <button class="toggle-btn" onclick="showView('llm')" id="llm-btn">🤖 LLM View</button>
                </div>

                <div class="repo-info" id="repo-info" style="display: none;">
                    <h3 id="repo-name"></h3>
                    <p id="repo-description"></p>
                    <div class="repo-stats">
                        <span class="stat">Files: <strong id="file-count">0</strong></span>
                        <span class="stat">Size: <strong id="total-size">0 B</strong></span>
                        <span class="stat">Language: <strong id="main-language">-</strong></span>
                    </div>
                </div>

                <!-- Advanced Controls Toggle -->
                <div class="advanced-controls-toggle" id="advanced-controls-toggle" style="display: none;">
                    <button class="toggle-advanced-btn" onclick="toggleAdvancedControls()" id="toggle-advanced-btn">
                        ⚙️ Advanced Controls
                    </button>
                </div>

                <!-- Branch/Tag Navigation -->
                <div class="branch-controls" id="branch-controls">
                    <div class="branch-selector">
                        <label for="branch-select">Branch/Tag:</label>
                        <select id="branch-select" onchange="switchBranchOrTag()">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div class="commit-info" id="commit-info">
                        <span>Latest commit:</span>
                        <a href="#" id="commit-link" class="commit-sha-link" target="_blank"></a>
                        <span id="commit-message"></span>
                    </div>
                </div>

                <!-- Search & Filter Controls -->
                <div class="search-controls" id="search-controls">
                    <div class="search-input-group">
                        <input type="text" 
                               class="search-input" 
                               id="search-input" 
                               placeholder="Search in file names and content..." 
                               onkeyup="handleSearchInput(event)">
                        <button class="search-btn" onclick="performSearch()" id="search-btn">
                            🔍 Search
                        </button>
                    </div>
                    
                    <div class="search-filters">
                        <label>
                            <input type="checkbox" id="filter-filenames" checked>
                            File names
                        </label>
                        <label>
                            <input type="checkbox" id="filter-content" checked>
                            File content
                        </label>
                        <label>
                            <input type="checkbox" id="filter-code">
                            Code files only
                        </label>
                    </div>
                    
                    <div class="search-options">
                        <label>
                            <input type="checkbox" id="regex-search">
                            Regular expressions
                        </label>
                        <label>
                            <input type="checkbox" id="case-sensitive">
                            Case sensitive
                        </label>
                    </div>
                    
                    <div class="file-type-filters" id="file-type-filters">
                        <!-- File type badges will be populated dynamically -->
                    </div>
                    
                    <div class="search-results" id="search-results" style="display: none;">
                        <div class="search-results-header">
                            <span class="search-results-count" id="search-results-count"></span>
                            <button class="clear-search-btn" onclick="clearSearch()">Clear Search</button>
                        </div>
                        <div id="search-results-list"></div>
                    </div>
                </div>

                <div class="human-view" id="human-view">
                    <div class="files-per-page">
                        <label for="files-per-page-select">Files per page:</label>
                        <select id="files-per-page-select" onchange="changeFilesPerPage()">
                            <option value="5">5</option>
                            <option value="10" selected>10</option>
                            <option value="20">20</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                            <option value="-1">All</option>
                        </select>
                    </div>
                    
                    <!-- Top Pagination -->
                    <div class="pagination-container" id="pagination-container-top" style="display: none;">
                        <div class="pagination-info" id="pagination-info-top"></div>
                        <div class="pagination" id="pagination-top"></div>
                    </div>
                    
                    <div class="content-layout">
                        <aside class="sidebar">
                            <h3>Files</h3>
                            <ul class="file-tree" id="file-tree"></ul>
                        </aside>
                        <div class="files-container" id="files-container"></div>
                    </div>
                    
                    <div class="pagination-container" id="pagination-container" style="display: none;">
                        <div class="pagination-info" id="pagination-info"></div>
                        <div class="pagination" id="pagination"></div>
                    </div>
                </div>

                <div class="llm-view" id="llm-view">
                    <h3>🤖 LLM View - CXML Format</h3>
                    <p>Copy the text below and paste it to an LLM for analysis:</p>
                    <textarea class="llm-textarea" id="llm-textarea" readonly></textarea>
                    <div class="copy-hint">
                        💡 <strong>Tip:</strong> Click in the text area and press Ctrl+A (Cmd+A on Mac) to select all, then Ctrl+C (Cmd+C) to copy.
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        Created by Mohamed Elashri
        <a href="https://github.com/MohamedElashri/grender" target="_blank">
            <svg class="github-icon" viewBox="0 0 16 16" fill="currentColor">
                <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
            </svg>
        </a>
    </footer>

    <script>
        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e.error);
            console.error('Error in file:', e.filename, 'at line:', e.lineno);
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);
        });
        
        // Configure marked.js for GitHub Flavored Markdown
        marked.setOptions({
            gfm: true,              // Enable GitHub Flavored Markdown
            breaks: true,           // Enable line breaks
            tables: true,           // Enable tables
            sanitize: false,        // Don't sanitize HTML (we trust GitHub content)
            smartLists: true,       // Use smarter list behavior
            smartypants: false,     // Don't use "smart" typography
            headerIds: true,        // Generate header IDs
            mangle: false,          // Don't mangle header IDs
        });
        
        // Configure marked renderer for better GitHub compatibility
        const renderer = new marked.Renderer();
        
        // Custom table rendering with GitHub classes
        renderer.table = function(header, body) {
            return `<div class="table-wrapper"><table class="markdown-table">
                <thead>${header}</thead>
                <tbody>${body}</tbody>
            </table></div>`;
        };
        
        // Custom code block rendering with syntax highlighting
        renderer.code = function(code, language) {
            if (language && hljs.getLanguage(language)) {
                try {
                    const highlighted = hljs.highlight(code, { language: language });
                    return `<div class="code-block-wrapper">
                        <div class="code-block-header">
                            <span class="code-language">${language}</span>
                        </div>
                        <pre class="hljs-container"><code class="hljs language-${language}">${highlighted.value}</code></pre>
                    </div>`;
                } catch (error) {
                    console.warn('Syntax highlighting failed for language:', language, error);
                }
            }
            // Fallback to auto-detection or plain text
            try {
                const highlighted = hljs.highlightAuto(code);
                const detectedLanguage = highlighted.language || 'text';
                return `<div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">${detectedLanguage}</span>
                    </div>
                    <pre class="hljs-container"><code class="hljs">${highlighted.value}</code></pre>
                </div>`;
            } catch (error) {
                const escapedCode = code
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                return `<pre class="code-block-wrapper"><code>${escapedCode}</code></pre>`;
            }
        };
        
        // Custom checkbox rendering for task lists
        renderer.listitem = function(text) {
            const isTaskList = /^\s*\[[ xX]\]\s+/.test(text);
            if (isTaskList) {
                const isChecked = /^\s*\[[xX]\]\s+/.test(text);
                const cleanText = text.replace(/^\s*\[[ xX]\]\s+/, '');
                return `<li class="task-list-item">
                    <input type="checkbox" class="task-list-item-checkbox" ${isChecked ? 'checked' : ''} disabled>
                    ${cleanText}
                </li>`;
            }
            return `<li>${text}</li>`;
        };
        
        // Custom link rendering for better security
        renderer.link = function(href, title, text) {
            const titleAttr = title ? ` title="${title}"` : '';
            const target = href.startsWith('http') ? ' target="_blank" rel="noopener noreferrer"' : '';
            return `<a href="${href}"${titleAttr}${target}>${text}</a>`;
        };
        
        // Apply the custom renderer
        marked.setOptions({ renderer: renderer });
        
        let currentTheme = 'light';
        let currentView = 'human';
        let repositoryData = null;
        
        // Pagination variables
        let currentPage = 1;
        let filesPerPage = 10;
        let totalPages = 1;

        // Theme management
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            const themeBtn = document.getElementById('theme-btn');
            if (themeBtn) {
                themeBtn.textContent = currentTheme === 'light' ? '🌙' : '☀️';
            }
            
            // Update highlight.js theme
            const lightLink = document.getElementById('highlight-light');
            const darkLink = document.getElementById('highlight-dark');
            
            if (lightLink && darkLink) {
                if (currentTheme === 'dark') {
                    lightLink.disabled = true;
                    darkLink.disabled = false;
                } else {
                    lightLink.disabled = false;
                    darkLink.disabled = true;
                }
            }
            
            localStorage.setItem('git-render-theme', currentTheme);
        }

        // Initialize theme from localStorage
        function initTheme() {
            const savedTheme = localStorage.getItem('git-render-theme');
            if (savedTheme && savedTheme !== currentTheme) {
                toggleTheme();
            }
        }

        // View switching
        function showView(view) {
            currentView = view;
            const humanView = document.getElementById('human-view');
            const llmView = document.getElementById('llm-view');
            const humanBtn = document.getElementById('human-btn');
            const llmBtn = document.getElementById('llm-btn');

            if (!humanView || !llmView || !humanBtn || !llmBtn) {
                console.warn('View switching elements not found');
                return;
            }

            if (view === 'human') {
                humanView.style.display = 'block';
                llmView.style.display = 'none';
                humanBtn.classList.add('active');
                llmBtn.classList.remove('active');
            } else {
                humanView.style.display = 'none';
                llmView.style.display = 'block';
                humanBtn.classList.remove('active');
                llmBtn.classList.add('active');
                
                // Auto-select text for easy copying
                setTimeout(() => {
                    const textarea = document.getElementById('llm-textarea');
                    if (textarea) {
                        textarea.focus();
                        textarea.select();
                    }
                }, 100);
            }
        }

        // Refresh app
        function refreshApp() {
            const repoInput = document.getElementById('repo-input');
            const resultsContainer = document.getElementById('results-container');
            const paginationContainer = document.getElementById('pagination-container');
            
            if (repoInput) repoInput.value = '';
            if (resultsContainer) resultsContainer.classList.remove('show');
            repositoryData = null;
            currentPage = 1;
            if (paginationContainer) paginationContainer.style.display = 'none';
        }

        // Pagination functions
        function changeFilesPerPage() {
            const select = document.getElementById('files-per-page-select');
            if (!select || !repositoryData) return;
            
            filesPerPage = parseInt(select.value);
            if (filesPerPage === -1) {
                filesPerPage = repositoryData.files.length; // Show all files
            }
            currentPage = 1;
            updatePagination();
            generateEnhancedFileSections();
        }

        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            generateEnhancedFileSections();
            updatePagination();
            
            // Scroll to top of files container
            const filesContainer = document.getElementById('files-container');
            if (filesContainer) {
                filesContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function updatePagination() {
            if (!repositoryData || !repositoryData.files) return;
            
            // Use helper function to get available files and count them
            const availableFiles = getAvailableFiles();
            const totalFiles = availableFiles.length;
            totalPages = Math.ceil(totalFiles / filesPerPage);
            
            // Get both top and bottom pagination elements
            const paginationContainers = [
                document.getElementById('pagination-container-top'),
                document.getElementById('pagination-container')
            ];
            const paginationInfos = [
                document.getElementById('pagination-info-top'),
                document.getElementById('pagination-info')
            ];
            const paginations = [
                document.getElementById('pagination-top'),
                document.getElementById('pagination')
            ];
            
            // Process both top and bottom pagination
            for (let i = 0; i < 2; i++) {
                const paginationContainer = paginationContainers[i];
                const paginationInfo = paginationInfos[i];
                const pagination = paginations[i];
                
                if (!paginationContainer || !paginationInfo || !pagination) {
                    console.warn(`Pagination elements not found for index ${i}`);
                    continue;
                }
                
                // Show/hide pagination based on whether it's needed
                if (totalPages <= 1) {
                    paginationContainer.style.display = 'none';
                    continue;
                } else {
                    paginationContainer.style.display = 'flex';
                }
                
                // Update pagination info
                const startFile = (currentPage - 1) * filesPerPage + 1;
                const endFile = Math.min(currentPage * filesPerPage, totalFiles);
                paginationInfo.textContent = `Showing ${startFile}-${endFile} of ${totalFiles} files`;
                
                // Generate pagination buttons
                pagination.innerHTML = '';
                
                // Previous button
                const prevBtn = document.createElement('button');
                prevBtn.textContent = '‹ Previous';
                prevBtn.disabled = currentPage === 1;
                prevBtn.onclick = () => goToPage(currentPage - 1);
                pagination.appendChild(prevBtn);
                
                // Page numbers
                const maxVisiblePages = window.innerWidth < 768 ? 3 : 7; // Fewer pages on mobile
                let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
                let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                
                // Adjust start page if we're near the end
                if (endPage - startPage < maxVisiblePages - 1) {
                    startPage = Math.max(1, endPage - maxVisiblePages + 1);
                }
                
                // First page and ellipsis
                if (startPage > 1) {
                    const firstBtn = document.createElement('button');
                    firstBtn.textContent = '1';
                    firstBtn.onclick = () => goToPage(1);
                    pagination.appendChild(firstBtn);
                    
                    if (startPage > 2) {
                        const ellipsis = document.createElement('span');
                        ellipsis.className = 'ellipsis';
                        ellipsis.textContent = '...';
                        pagination.appendChild(ellipsis);
                    }
                }
                
                // Page number buttons
                for (let pageNum = startPage; pageNum <= endPage; pageNum++) {
                    const pageBtn = document.createElement('button');
                    pageBtn.textContent = pageNum.toString();
                    pageBtn.className = pageNum === currentPage ? 'active' : '';
                    pageBtn.onclick = () => goToPage(pageNum);
                    pagination.appendChild(pageBtn);
                }
                
                // Last page and ellipsis
                if (endPage < totalPages) {
                    if (endPage < totalPages - 1) {
                        const ellipsis = document.createElement('span');
                        ellipsis.className = 'ellipsis';
                        ellipsis.textContent = '...';
                        pagination.appendChild(ellipsis);
                    }
                    
                    const lastBtn = document.createElement('button');
                    lastBtn.textContent = totalPages.toString();
                    lastBtn.onclick = () => goToPage(totalPages);
                    pagination.appendChild(lastBtn);
                }
                
                // Next button
                const nextBtn = document.createElement('button');
                nextBtn.textContent = 'Next ›';
                nextBtn.disabled = currentPage === totalPages;
                nextBtn.onclick = () => goToPage(currentPage + 1);
                pagination.appendChild(nextBtn);
            }
        }

        // Responsive files per page adjustment
        function adjustFilesPerPageForScreen() {
            const width = window.innerWidth;
            const select = document.getElementById('files-per-page-select');
            
            if (!select) return;
            
            // Auto-adjust files per page based on screen size if not manually set
            if (!select.dataset.manuallySet) {
                if (width < 768) { // Mobile
                    filesPerPage = 5;
                    select.value = '5';
                } else if (width < 1024) { // Tablet
                    filesPerPage = 10;
                    select.value = '10';
                } else { // Desktop
                    filesPerPage = 20;
                    select.value = '20';
                }
            }
        }

        // Toggle GitHub token visibility
        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('github-token');
            const toggleBtn = document.getElementById('token-toggle');
            
            if (!tokenInput || !toggleBtn) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                toggleBtn.textContent = '🙈 Hide Token';
            } else {
                tokenInput.type = 'password';
                toggleBtn.textContent = '👁️ Show Token';
            }
        }

        // Reset file limit to default
        function resetFileLimit() {
            const fileLimitInput = document.getElementById('file-limit');
            if (!fileLimitInput) return;
            
            fileLimitInput.value = '';
            
            // Show a brief confirmation
            const resetBtn = document.getElementById('reset-limit-btn');
            if (resetBtn) {
                const originalText = resetBtn.textContent;
                resetBtn.textContent = '✅ Reset';
                resetBtn.style.background = 'var(--accent-primary)';
                resetBtn.style.color = 'white';
                
                setTimeout(() => {
                    resetBtn.textContent = originalText;
                    resetBtn.style.background = '';
                    resetBtn.style.color = '';
                }, 1500);
            }
        }

        // Show/hide file limit information
        function showFileLimitInfo() {
            const infoDiv = document.getElementById('file-limit-info');
            const infoBtn = document.getElementById('limit-info-btn');
            
            if (!infoDiv || !infoBtn) return;
            
            if (infoDiv.style.display === 'none') {
                infoDiv.style.display = 'block';
                infoBtn.textContent = '❌ Hide';
                infoBtn.style.background = 'var(--accent-primary)';
                infoBtn.style.color = 'white';
            } else {
                infoDiv.style.display = 'none';
                infoBtn.textContent = 'ℹ️ Info';
                infoBtn.style.background = '';
                infoBtn.style.color = '';
            }
        }

        // Get user-specified file limit or default
        function getFileLimit() {
            const fileLimitInput = document.getElementById('file-limit');
            const githubToken = document.getElementById('github-token').value.trim();
            
            // Check if user has specified a custom limit
            if (fileLimitInput && fileLimitInput.value && fileLimitInput.value.trim()) {
                const customLimit = parseInt(fileLimitInput.value.trim());
                
                if (!isNaN(customLimit) && customLimit > 0 && customLimit <= 1000) {
                    // Save to localStorage for persistence
                    localStorage.setItem('git-render-file-limit', customLimit.toString());
                    return customLimit;
                }
            }
            
            // Return default limits based on token availability
            return githubToken ? 200 : 50;
        }

        // Helper function to get files that have successfully loaded content
        function getAvailableFiles() {
            if (!repositoryData || !repositoryData.files) return [];
            
            return repositoryData.files.filter(file => {
                // Include files that:
                // 1. Have content === null (not yet loaded, available for lazy loading)
                // 2. Have actual content (successfully loaded)
                // Exclude files that failed to load (have error messages)
                return file.content === null || 
                       (file.content && 
                        !file.content.startsWith('[Error loading file:') && 
                        !file.content.startsWith('Failed to load') && 
                        file.content !== '[Content not available]');
            });
        }

        // Sort files with README.md first, then by directory structure
        function sortFilesByStructure(files) {
            return files.sort((a, b) => {
                // Only root README.md comes first (no slash in path)
                const aIsRootReadme = a.path.toLowerCase() === 'readme.md';
                const bIsRootReadme = b.path.toLowerCase() === 'readme.md';
                
                if (aIsRootReadme && !bIsRootReadme) return -1;
                if (!aIsRootReadme && bIsRootReadme) return 1;
                
                // For all other files (including non-root README.md), sort by directory structure
                const aParts = a.path.split('/');
                const bParts = b.path.split('/');
                
                // Compare directory depth (root files first)
                if (aParts.length !== bParts.length) {
                    return aParts.length - bParts.length;
                }
                
                // Compare path components
                for (let i = 0; i < Math.min(aParts.length, bParts.length); i++) {
                    const comparison = aParts[i].localeCompare(bParts[i]);
                    if (comparison !== 0) return comparison;
                }
                
                return 0;
            });
        }

        // Load saved file limit from localStorage
        function loadSavedFileLimit() {
            const fileLimitInput = document.getElementById('file-limit');
            const savedLimit = localStorage.getItem('git-render-file-limit');
            
            if (fileLimitInput && savedLimit) {
                const limit = parseInt(savedLimit);
                if (!isNaN(limit) && limit > 0 && limit <= 1000) {
                    fileLimitInput.value = limit.toString();
                }
            }
        }

        // Get GitHub API headers with optional token
        function getGitHubHeaders() {
            const tokenInput = document.getElementById('github-token');
            const token = tokenInput ? tokenInput.value.trim() : '';
            const headers = {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'GitRender-WebApp'
            };
            
            if (token) {
                // Validate token format (GitHub tokens are usually 40 characters)
                if (token.length < 20) {
                    console.warn('GitHub token seems too short, please verify it\'s correct');
                }
                headers['Authorization'] = `token ${token}`;
            }
            
            return headers;
        }

        // Check GitHub API rate limit status
        async function checkRateLimit() {
            try {
                const headers = getGitHubHeaders();
                const response = await fetch('https://api.github.com/rate_limit', { headers });
                
                if (response.ok) {
                    const rateLimit = await response.json();
                    const remaining = rateLimit.rate.remaining;
                    const resetTime = new Date(rateLimit.rate.reset * 1000);
                    
                    console.log(`GitHub API: ${remaining} requests remaining, resets at ${resetTime.toLocaleTimeString()}`);
                    
                    if (remaining < 10) {
                        const tokenInput = document.getElementById('github-token');
                        const token = tokenInput ? tokenInput.value.trim() : '';
                        if (!token) {
                            alert(`Warning: Only ${remaining} API requests remaining. Consider adding a GitHub token to avoid rate limits.`);
                        }
                    }
                    
                    return rateLimit;
                }
            } catch (error) {
                console.warn('Could not check rate limit:', error);
            }
            return null;
        }

        // Extract repository info from URL
        function parseRepoUrl(url) {
            const match = url.match(/github\.com\/([^\/]+)\/([^\/\?#]+)/);
            if (!match) return null;
            
            const owner = match[1];
            let repo = match[2];
            
            // Remove .git suffix if present
            if (repo.endsWith('.git')) {
                repo = repo.slice(0, -4);
            }
            
            return { owner, repo };
        }

        // Format file size
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KiB', 'MiB', 'GiB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Get file extension
        function getFileExtension(filename) {
            return filename.split('.').pop().toLowerCase();
        }

        // Check if file is markdown
        function isMarkdownFile(filename) {
            const ext = getFileExtension(filename);
            return ['md', 'markdown', 'mdown', 'mkd', 'mkdn'].includes(ext);
        }

        // Check if file is Jupyter notebook
        function isJupyterNotebook(filename) {
            const ext = getFileExtension(filename);
            return ext === 'ipynb';
        }

        // Parse Jupyter notebook content and extract readable cells
        // Note: Jupyter notebooks are exempt from size limits due to their special parsing
        function parseJupyterNotebook(content) {
            try {
                const notebook = JSON.parse(content);
                let extractedContent = '';
                
                if (!notebook.cells || !Array.isArray(notebook.cells)) {
                    return 'Invalid Jupyter notebook format: no cells found';
                }
                
                // Add notebook metadata as header
                extractedContent += '# Jupyter Notebook\n\n';
                if (notebook.metadata && notebook.metadata.kernelspec) {
                    extractedContent += `**Kernel:** ${notebook.metadata.kernelspec.display_name || notebook.metadata.kernelspec.name}\n\n`;
                }
                
                notebook.cells.forEach((cell, index) => {
                    const cellType = cell.cell_type;
                    const source = Array.isArray(cell.source) ? cell.source.join('') : cell.source || '';
                    
                    if (cellType === 'markdown') {
                        // Add markdown cells as-is
                        if (source.trim()) {
                            extractedContent += source + '\n\n';
                        }
                    } else if (cellType === 'code') {
                        // Add code cells with proper formatting
                        if (source.trim()) {
                            // Determine language from kernel metadata
                            let language = 'python'; // Default to Python
                            if (notebook.metadata && notebook.metadata.kernelspec) {
                                const kernelName = notebook.metadata.kernelspec.name || '';
                                if (kernelName.includes('julia')) language = 'julia';
                                else if (kernelName.includes('r')) language = 'r';
                                else if (kernelName.includes('scala')) language = 'scala';
                                else if (kernelName.includes('javascript') || kernelName.includes('node')) language = 'javascript';
                            }
                            
                            extractedContent += `\`\`\`${language}\n${source}\`\`\`\n\n`;
                        }
                        
                        // Add outputs if they exist and are text-based
                        if (cell.outputs && Array.isArray(cell.outputs)) {
                            cell.outputs.forEach(output => {
                                if (output.output_type === 'stream' && output.text) {
                                    const outputText = Array.isArray(output.text) ? output.text.join('') : output.text;
                                    if (outputText.trim()) {
                                        extractedContent += `**Output:**\n\`\`\`\n${outputText}\`\`\`\n\n`;
                                    }
                                } else if (output.output_type === 'execute_result' && output.data && output.data['text/plain']) {
                                    const outputText = Array.isArray(output.data['text/plain']) ? 
                                        output.data['text/plain'].join('') : output.data['text/plain'];
                                    if (outputText.trim()) {
                                        extractedContent += `**Result:**\n\`\`\`\n${outputText}\`\`\`\n\n`;
                                    }
                                } else if (output.output_type === 'error') {
                                    const traceback = output.traceback ? output.traceback.join('\n') : '';
                                    if (traceback.trim()) {
                                        extractedContent += `**Error:**\n\`\`\`\n${traceback}\`\`\`\n\n`;
                                    }
                                }
                            });
                        }
                    } else if (cellType === 'raw') {
                        // Add raw cells as code blocks
                        if (source.trim()) {
                            extractedContent += `\`\`\`\n${source}\`\`\`\n\n`;
                        }
                    }
                });
                
                return extractedContent;
            } catch (error) {
                console.warn('Failed to parse Jupyter notebook:', error);
                return `Error parsing Jupyter notebook: ${error.message}\n\nRaw content:\n\`\`\`json\n${content}\`\`\``;
            }
        }

        // Enhanced file categorization with better binary detection
        const BINARY_EXTENSIONS = new Set([
            'png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico',
            'pdf', 'zip', 'tar', 'gz', 'bz2', 'xz', '7z', 'rar',
            'mp3', 'mp4', 'mov', 'avi', 'mkv', 'wav', 'ogg', 'flac',
            'ttf', 'otf', 'eot', 'woff', 'woff2',
            'so', 'dll', 'dylib', 'class', 'jar', 'exe', 'bin',
            'deb', 'rpm', 'dmg', 'pkg', 'msi'
        ]);

        // Known text file extensions that should never be treated as binary
        const TEXT_EXTENSIONS = new Set([
            'txt', 'md', 'markdown', 'rst', 'py', 'js', 'ts', 'html', 'css', 'scss', 'sass',
            'json', 'xml', 'yaml', 'yml', 'toml', 'ini', 'cfg', 'conf', 'config',
            'sh', 'bash', 'zsh', 'fish', 'ps1', 'bat', 'cmd',
            'c', 'cpp', 'cxx', 'cc', 'h', 'hpp', 'hxx',
            'java', 'kt', 'scala', 'go', 'rs', 'swift', 'dart',
            'php', 'rb', 'pl', 'pm', 'r', 'julia', 'jl',
            'sql', 'sqlite', 'prisma',
            'dockerfile', 'makefile', 'cmake', 'gradle',
            'gitignore', 'gitattributes', 'editorconfig',
            'license', 'readme', 'changelog', 'todo', 'authors',
            'log', 'env', 'example',
            'ipynb' // Add Jupyter notebooks as text files
        ]);

        function categorizeFile(filename, size) {
            // First, check for explicit git and repository metadata files that should NEVER be included
            const basename = filename.split('/').pop().toLowerCase();
            
            // EXPLICIT DEBUG: Log every call to this function for .gitattributes
            if (basename === '.gitattributes') {
                console.error('🚨 CATEGORIZING .gitattributes:', filename);
            }
            
            // Explicit list of files to ignore (case-insensitive)
            const explicitIgnoreList = [
                '.gitignore', '.gitattributes', '.gitmodules',
                'license', 'license.md', 'license.txt', 'licence', 'licence.md', 'licence.txt',
                'contributors.md', 'contributing.md', 'code_of_conduct.md', 'security.md', 'funding.yml',
                'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', 'poetry.lock', 'pipfile.lock',
                '.ds_store', 'thumbs.db', 'desktop.ini'
            ];
            
            if (explicitIgnoreList.includes(basename)) {
                console.error('🚨 IGNORING FILE:', filename, 'basename:', basename);
                return { include: false, reason: 'ignored', category: 'ignored' };
            }
            
            // Check if it's in a git directory
            if (filename.includes('/.git/') || filename.startsWith('.git/')) {
                return { include: false, reason: 'ignored', category: 'ignored' };
            }
            
            // Check directory patterns to ignore
            const ignoredDirPatterns = [
                '/.github/', '/.vscode/', '/.idea/', '/.vs/',
                '/node_modules/', '/__pycache__/', '/.pytest_cache/', '/.mypy_cache/',
                '/vendor/', '/deps/', '/target/', '/build/', '/dist/',
                '/.devcontainer/', '/.devenv/', '/.anthropic/', '/.openai/'
            ];
            
            if (ignoredDirPatterns.some(pattern => filename.includes(pattern)) ||
                filename.startsWith('.github/') ||
                filename.startsWith('.vscode/') ||
                filename.startsWith('node_modules/') ||
                filename.startsWith('__pycache__/')) {
                return { include: false, reason: 'ignored', category: 'ignored' };
            }
            
            // Check file size (except for Jupyter notebooks which should always be processed)
            const maxSize = 100 * 1024; // 100KB limit
            const ext = getFileExtension(filename);
            if (size > maxSize && ext !== 'ipynb') {
                return { include: false, reason: 'too_large', category: 'large' };
            }
            
            // Check if it's a known binary file
            if (BINARY_EXTENSIONS.has(ext)) {
                return { include: false, reason: 'binary', category: 'binary' };
            }
            
            // Check if it's a known text file
            if (TEXT_EXTENSIONS.has(ext)) {
                return { include: true, reason: 'ok', category: 'text' };
            }
            
            // Check for files without extensions that are commonly text
            if (!ext) {
                if (TEXT_EXTENSIONS.has(basename) || 
                    basename.includes('readme') || 
                    basename.includes('makefile') ||
                    basename.includes('dockerfile') ||
                    basename.includes('changelog') ||
                    basename.includes('todo')) {
                    return { include: true, reason: 'ok', category: 'text' };
                }
            }
            
            // For unknown extensions, assume text but be cautious
            return { include: true, reason: 'ok', category: 'text' };
        }

        // Legacy function for compatibility
        function shouldSkipFile(filename, size) {
            return !categorizeFile(filename, size).include;
        }

        // Enhanced repository contents fetching with categorization
        async function fetchRepositoryContents(owner, repo) {
            const loading = document.getElementById('loading');
            const renderBtn = document.getElementById('render-btn');
            
            loading.style.display = 'flex';
            renderBtn.disabled = true;
            
            try {
                const headers = getGitHubHeaders();
                
                // Fetch repository info
                const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
                if (!repoResponse.ok) {
                    if (repoResponse.status === 404) {
                        throw new Error('Repository not found or is private');
                    } else if (repoResponse.status === 403) {
                        const resetTime = repoResponse.headers.get('X-RateLimit-Reset');
                        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000).toLocaleTimeString() : 'unknown';
                        throw new Error(`API rate limit exceeded. Rate limit resets at ${resetDate}. Consider adding a GitHub token.`);
                    } else if (repoResponse.status === 401) {
                        throw new Error('Invalid GitHub token. Please check your token and try again.');
                    } else {
                        throw new Error(`Failed to fetch repository: ${repoResponse.status}`);
                    }
                }
                const repoInfo = await repoResponse.json();
                
                // Fetch repository tree
                const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${repoInfo.default_branch}?recursive=1`, { headers });
                if (!treeResponse.ok) {
                    if (treeResponse.status === 403) {
                        const resetTime = treeResponse.headers.get('X-RateLimit-Reset');
                        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000).toLocaleTimeString() : 'unknown';
                        throw new Error(`API rate limit exceeded while fetching repository tree. Rate limit resets at ${resetDate}. Consider adding a GitHub token.`);
                    }
                    throw new Error('Failed to fetch repository contents');
                }
                const treeData = await treeResponse.json();
                
                // Categorize all files - filter out ignored files immediately
                const allFiles = [];
                const categorizedFiles = {
                    rendered: [],
                    binary: [],
                    large: [],
                    ignored: [],
                    failed: [] // New category for files that failed to fetch
                };
                
                for (const item of treeData.tree) {
                    if (item.type === 'blob') {
                        const category = categorizeFile(item.path, item.size || 0);
                        
                        // EXPLICIT DEBUG: Check for .gitattributes in categorization
                        if (item.path === '.gitattributes' || item.path.endsWith('/.gitattributes')) {
                            console.error('🚨 PROCESSING .gitattributes - Category:', category);
                        }
                        
                        const fileInfo = {
                            path: item.path,
                            size: item.size || 0,
                            sha: item.sha,
                            category: category
                        };
                        
                        // Only add to allFiles if not ignored (to save memory and processing)
                        if (category.category !== 'ignored') {
                            allFiles.push(fileInfo);
                        } else {
                            console.log('✅ FILTERED OUT:', item.path, 'Category:', category.category);
                        }
                        
                        if (category.include) {
                            categorizedFiles.rendered.push(fileInfo);
                            console.log('📝 ADDED TO RENDERED:', item.path);
                        } else {
                            // Map category names to match the structure
                            const categoryKey = category.category === 'ignored' ? 'ignored' : 
                                              category.category === 'large' ? 'large' : 'binary';
                            categorizedFiles[categoryKey].push(fileInfo);
                        }
                    }
                }
                
                totalFilesToProcess = categorizedFiles.rendered.length;
                
                // Limit the number of files to process to avoid rate limits
                // Use user-specified limit or defaults: 50 without token, 200 with token
                const maxFiles = getFileLimit();
                const githubToken = document.getElementById('github-token').value.trim();
                const fileLimitInput = document.getElementById('file-limit');
                const isCustomLimit = fileLimitInput && fileLimitInput.value && fileLimitInput.value.trim() !== '';
                
                if (totalFilesToProcess > maxFiles) {
                    const limitType = isCustomLimit ? 'custom' : (githubToken ? 'token-default' : 'no-token-default');
                    console.warn(`Repository has ${totalFilesToProcess} files to render. Limiting to ${maxFiles} files (${limitType} limit).`);
                    
                    // Sort files by directory structure with README.md priority
                    categorizedFiles.rendered = sortFilesByStructure(categorizedFiles.rendered);
                    
                    // Move excess files to a new "truncated" category
                    const truncatedFiles = categorizedFiles.rendered.splice(maxFiles);
                    if (!categorizedFiles.truncated) categorizedFiles.truncated = [];
                    categorizedFiles.truncated.push(...truncatedFiles);
                    
                    totalFilesToProcess = categorizedFiles.rendered.length;
                }
                
                if (totalFilesToProcess === 0) {
                    return {
                        repoInfo,
                        files: [],
                        categorizedFiles,
                        allFiles,
                        totalSize: 0,
                        treeStructure: await generateTreeStructure(treeData.tree)
                    };
                }
                
                // Helper function to fetch file content with multiple fallback methods
                async function fetchFileContent(fileInfo, repoInfo) {
                    const methods = [
                        // Method 1: Raw GitHub content (no rate limit for public repos)
                        {
                            name: 'raw',
                            fetch: () => fetch(`https://raw.githubusercontent.com/${owner}/${repo}/${repoInfo.default_branch}/${fileInfo.path}`)
                        },
                        // Method 2: Git Blob API (more efficient than Contents API)
                        {
                            name: 'blob',
                            fetch: () => fetch(`https://api.github.com/repos/${owner}/${repo}/git/blobs/${fileInfo.sha}`, { headers })
                        },
                        // Method 3: Contents API (fallback)
                        {
                            name: 'contents',
                            fetch: () => fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${fileInfo.path}`, { headers })
                        }
                    ];

                    for (const method of methods) {
                        try {
                            const response = await method.fetch();
                            
                            if (response.ok) {
                                let content;
                                
                                if (method.name === 'raw') {
                                    content = await response.text();
                                } else if (method.name === 'blob') {
                                    const data = await response.json();
                                    content = data.encoding === 'base64' ? atob(data.content) : data.content;
                                } else { // contents
                                    const data = await response.json();
                                    content = atob(data.content);
                                }
                                
                                return { content, method: method.name };
                            }
                        } catch (error) {
                            console.warn(`Failed to fetch ${fileInfo.path} using ${method.name}:`, error.message);
                            continue;
                        }
                    }
                    
                    throw new Error(`All methods failed for ${fileInfo.path}`);
                }

                // Store file metadata without content for lazy loading
                const filesList = categorizedFiles.rendered.map(fileInfo => ({
                    path: fileInfo.path,
                    size: fileInfo.size,
                    sha: fileInfo.sha,
                    content: null // Will be loaded lazily when needed
                }));
                
                return {
                    repoInfo,
                    files: filesList,
                    categorizedFiles,
                    allFiles,
                    totalSize: categorizedFiles.rendered.reduce((sum, file) => sum + (file.size || 0), 0),
                    treeStructure: await generateTreeStructure(treeData.tree)
                };
                
            } catch (error) {
                throw error;
            } finally {
                loading.style.display = 'none';
                renderBtn.disabled = false;
            }
        }

        // Render file content with syntax highlighting and overflow handling
        function renderFileContent(content, filename) {
            if (isJupyterNotebook(filename)) {
                // Parse Jupyter notebook and extract readable content
                const extractedContent = parseJupyterNotebook(content);
                try {
                    // Render the extracted content as markdown
                    let html = marked.parse(extractedContent);
                    html = processGitHubFeatures(html, extractedContent);
                    return `<div class="markdown-content jupyter-notebook">
                        <div class="notebook-header" style="background: var(--bg-tertiary); padding: 0.5rem 1rem; margin: -1rem -1.5rem 1rem -1.5rem; border-bottom: 1px solid var(--border-primary); font-size: 0.9rem; color: var(--text-secondary);">
                            📓 Jupyter Notebook - Parsed content (cells and outputs)
                        </div>
                        ${html}
                    </div>`;
                } catch (error) {
                    console.warn('Markdown parsing failed for Jupyter notebook:', error);
                    // Fallback to escaped content
                    const escapedContent = extractedContent
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    return `<div class="notebook-header" style="background: var(--bg-tertiary); padding: 0.5rem 1rem; margin: -1rem -1.5rem 1rem -1.5rem; border-bottom: 1px solid var(--border-primary); font-size: 0.9rem; color: var(--text-secondary);">
                        📓 Jupyter Notebook - Parsed content (fallback)
                    </div>
                    <pre><code>${escapedContent}</code></pre>`;
                }
            } else if (isMarkdownFile(filename)) {
                try {
                    // Process the markdown with our configured marked renderer
                    let html = marked.parse(content);
                    
                    // Post-process for additional GitHub features
                    html = processGitHubFeatures(html, content);
                    
                    return `<div class="markdown-content">${html}</div>`;
                } catch (error) {
                    console.warn('Markdown parsing failed:', error);
                    // Fallback to plain text if markdown parsing fails
                    const escapedContent = content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    return `<pre><code>${escapedContent}</code></pre>`;
                }
            } else {
                try {
                    const highlighted = hljs.highlightAuto(content, [getFileExtension(filename)]);
                    return `<pre class="hljs-container"><code class="hljs">${highlighted.value}</code></pre>`;
                } catch (error) {
                    // Fallback to plain text with proper escaping
                    const escapedContent = content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                    return `<pre><code>${escapedContent}</code></pre>`;
                }
            }
        }

        // Process additional GitHub-specific markdown features
        function processGitHubFeatures(html, originalContent) {
            // Handle @mentions (basic styling)
            html = html.replace(/@([a-zA-Z0-9_-]+)/g, '<span class="mention">@$1</span>');
            
            // Handle issue/PR references like #123
            html = html.replace(/#(\d+)/g, '<span class="issue-reference">#$1</span>');
            
            // Handle commit SHA references (basic 7+ char hex)
            html = html.replace(/\b([a-f0-9]{7,40})\b/g, '<code class="commit-sha">$1</code>');
            
            return html;
        }

        // Generate CXML format for LLM (with lazy loading support)
        async function generateCXML(files) {
            let cxml = '<documents>\n';
            
            // Get available files and sort them properly
            const availableFiles = getAvailableFiles();
            if (!availableFiles || availableFiles.length === 0) {
                console.warn('No available files for generateCXML');
                return '<documents>\n</documents>';
            }
            
            // Sort files with README.md first for better LLM context
            const sortedFiles = sortFilesByStructure([...availableFiles]);
            
            let docIndex = 1;
            for (const file of sortedFiles) {
                // Skip binary or ignored files
                const category = categorizeFile(file.path, file.size || 0);
                if (category.category === 'ignored' || category.category === 'binary') {
                    continue;
                }
                
                cxml += `<document index="${docIndex}">\n`;
                cxml += `<source>${file.path}</source>\n`;
                cxml += '<document_content>\n';
                
                // Try to get content
                if (file.content && 
                    !file.content.startsWith('[Error loading file:') && 
                    !file.content.startsWith('Failed to load') && 
                    file.content !== '[Content not available]') {
                    cxml += file.content;
                } else if (file.sha) {
                    try {
                        const content = await fetchSingleFileContent(file);
                        if (content && 
                            !content.startsWith('[Error loading file:') && 
                            !content.startsWith('Failed to load') && 
                            content !== '[Content not available]') {
                            cxml += content;
                            // Cache the content
                            filesContentCache.set(file.path, content);
                        } else {
                            // Skip files with error content
                            continue;
                        }
                    } catch (error) {
                        // Skip files that fail to load
                        continue;
                    }
                } else {
                    // Skip files without content or sha
                    continue;
                }
                
                cxml += '\n</document_content>\n';
                cxml += '</document>\n';
                
                docIndex++;
            }
            
            cxml += '</documents>';
            return cxml;
        }

        // Generate directory tree structure (only non-ignored files)
        async function generateTreeStructure(treeData) {
            const directories = new Set();
            const files = [];
            
            // Collect all directories and files, but filter out ignored files
            for (const item of treeData) {
                if (item.type === 'tree') {
                    directories.add(item.path);
                } else if (item.type === 'blob') {
                    // Check if this file should be ignored
                    const category = categorizeFile(item.path, item.size || 0);
                    if (category.category !== 'ignored') {
                        files.push(item.path);
                        // Add parent directories
                        const parts = item.path.split('/');
                        for (let i = 1; i < parts.length; i++) {
                            directories.add(parts.slice(0, i).join('/'));
                        }
                    }
                }
            }
            
            // Sort directories and files
            const sortedDirs = Array.from(directories).sort();
            const sortedFiles = files.sort();
            
            // Build tree representation
            const tree = [];
            const processed = new Set();
            
            function addToTree(path, isFile = false) {
                if (processed.has(path)) return;
                processed.add(path);
                
                const parts = path.split('/');
                const depth = parts.length - 1;
                const name = parts[parts.length - 1];
                const prefix = '  '.repeat(depth);
                
                if (depth === 0) {
                    tree.push(`${name}${isFile ? '' : '/'}`);
                } else {
                    tree.push(`${prefix}├── ${name}${isFile ? '' : '/'}`);
                }
            }
            
            // Add directories first
            for (const dir of sortedDirs) {
                addToTree(dir, false);
            }
            
            // Add files
            for (const file of sortedFiles) {
                if (!processed.has(file)) {
                    addToTree(file, true);
                }
            }
            
            return tree.join('\n');
        }

        // Add repository validation
        function validateRepoUrl(url) {
            const githubPattern = /^https?:\/\/(www\.)?github\.com\/[a-zA-Z0-9-_]+\/[a-zA-Z0-9-_.]+\/?(\?.*)?$/;
            return githubPattern.test(url);
        }

        // Main repository rendering function (enhanced)
        async function renderRepository() {
            const repoUrl = document.getElementById('repo-input').value.trim();
            if (!repoUrl) {
                alert('Please enter a GitHub repository URL');
                return;
            }
            
            if (!validateRepoUrl(repoUrl)) {
                alert('Please enter a valid GitHub repository URL (e.g., https://github.com/username/repository)');
                return;
            }
            
            const repoInfo = parseRepoUrl(repoUrl);
            if (!repoInfo) {
                alert('Could not parse repository information from URL');
                return;
            }
            
            try {
                // Update loading message with file limit info
                const loading = document.getElementById('loading');
                const loadingText = loading ? loading.querySelector('span') : null;
                const currentLimit = getFileLimit();
                const isCustomLimit = document.getElementById('file-limit').value.trim() !== '';
                const githubToken = document.getElementById('github-token').value.trim();
                
                if (loadingText) {
                    const limitType = isCustomLimit ? 'custom' : (githubToken ? 'with token' : 'no token');
                    loadingText.textContent = `Processing repository... (limit: ${currentLimit} files, ${limitType})`;
                }
                
                // Check rate limit before starting
                await checkRateLimit();
                
                // Reset progress tracking
                processedFiles = 0;
                totalFilesToProcess = 0;
                
                // Use enhanced rendering with branch support
                await renderRepositoryWithBranch(repoUrl, null); // null means use default branch
                
            } catch (error) {
                const errorMessage = handleApiError(error, 'Repository rendering');
                alert(errorMessage);
            }
        }

        // Handle Enter key in input
        document.addEventListener('DOMContentLoaded', function() {
            const repoInput = document.getElementById('repo-input');
            if (repoInput) {
                repoInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        renderRepository();
                    }
                });
            }
            
            // Update file limit placeholder when token changes
            const tokenInput = document.getElementById('github-token');
            const fileLimitInput = document.getElementById('file-limit');
            
            if (tokenInput && fileLimitInput) {
                function updateFileLimitPlaceholder() {
                    const hasToken = tokenInput.value.trim() !== '';
                    const defaultLimit = hasToken ? 200 : 50;
                    fileLimitInput.placeholder = `Max files to process (default: ${defaultLimit}${hasToken ? ' with token' : ' without token'})`;
                }
                
                // Update placeholder initially and when token changes
                updateFileLimitPlaceholder();
                tokenInput.addEventListener('input', updateFileLimitPlaceholder);
                tokenInput.addEventListener('paste', () => setTimeout(updateFileLimitPlaceholder, 0));
            }
        });

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            try {
                initTheme();
                loadSavedFileLimit(); // Load saved file limit
                
                // Set responsive defaults for files per page
                adjustFilesPerPageForScreen();
                
                // Load saved GitHub token
                const savedToken = localStorage.getItem('github-token');
                const tokenInput = document.getElementById('github-token');
                if (savedToken && tokenInput) {
                    tokenInput.value = savedToken;
                }
                
                // Save token when it changes
                if (tokenInput) {
                    tokenInput.addEventListener('input', function() {
                        const token = this.value.trim();
                        if (token) {
                            localStorage.setItem('github-token', token);
                        } else {
                            localStorage.removeItem('github-token');
                        }
                    });
                }
                
                // Mark files per page as manually set when user changes it
                const filesPerPageSelect = document.getElementById('files-per-page-select');
                if (filesPerPageSelect) {
                    filesPerPageSelect.addEventListener('change', function() {
                        this.dataset.manuallySet = 'true';
                    });
                }
            } catch (error) {
                console.error('Error during app initialization:', error);
            }
            
            // Add some example URLs for testing
            const exampleRepos = [
                'https://github.com/karpathy/nanoGPT',
                'https://github.com/facebook/react',
                'https://github.com/microsoft/vscode'
            ];
            
            // You can uncomment this to show example repos
            // console.log('Example repositories you can try:', exampleRepos);
        });

        // Function to find which page a file is on
        function findPageForFile(filePath) {
            if (!repositoryData || !repositoryData.files) return null;
            
            // Use helper function to get available files and sort them by structure
            const availableFiles = getAvailableFiles();
            const sortedFiles = sortFilesByStructure([...availableFiles]);
            
            // Find the index of the file in the sorted array
            const fileIndex = sortedFiles.findIndex(file => file.path === filePath);
            if (fileIndex === -1) return null;
            
            // Calculate which page this file is on
            const pageNumber = Math.floor(fileIndex / filesPerPage) + 1;
            return pageNumber;
        }

        // Function to navigate to a file (with page navigation if needed)
        function navigateToFile(filePath) {
            const targetPage = findPageForFile(filePath);
            if (!targetPage) return false;
            
            // If the file is on a different page, navigate to that page first
            if (targetPage !== currentPage) {
                currentPage = targetPage;
                generateEnhancedFileSections();
                updatePagination();
                
                // After the page updates, scroll to the file with a slight delay
                setTimeout(() => {
                    const fileId = filePath.replace(/[^a-zA-Z0-9-_]/g, '-');
                    const target = document.querySelector(`#file-${fileId}`);
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            } else {
                // File is on current page, just scroll to it
                const fileId = filePath.replace(/[^a-zA-Z0-9-_]/g, '-');
                const target = document.querySelector(`#file-${fileId}`);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
            return true;
        }

        // Smooth scrolling for anchor links with page navigation
        document.addEventListener('click', function(e) {
            if (e.target.tagName === 'A' && e.target.getAttribute('href').startsWith('#file-')) {
                e.preventDefault();
                
                // Extract file path from the link's title attribute or find it from the file list
                const fileId = e.target.getAttribute('href').substring(6); // Remove '#file-' prefix
                
                // Find the file path by looking through available files
                const availableFiles = getAvailableFiles();
                const targetFile = availableFiles.find(file => {
                    const normalizedPath = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                    return normalizedPath === fileId;
                });
                
                if (targetFile) {
                    navigateToFile(targetFile.path);
                } else {
                    // Fallback to original behavior if file not found
                    const target = document.querySelector(e.target.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }
            }
        });

        // Copy to clipboard functionality for LLM view
        document.addEventListener('DOMContentLoaded', function() {
            const llmTextarea = document.getElementById('llm-textarea');
            if (llmTextarea) {
                llmTextarea.addEventListener('click', function() {
                    this.select();
                });
            }
        });

        // Add keyboard shortcut for copying in LLM view
        document.addEventListener('keydown', function(e) {
            if (currentView === 'llm' && (e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                const textarea = document.getElementById('llm-textarea');
                textarea.focus();
                textarea.select();
            }
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            // Recalculate layout if needed
            const sidebar = document.querySelector('.sidebar');
            if (window.innerWidth <= 768) {
                if (sidebar && sidebar.style.position === 'sticky') {
                    sidebar.style.position = 'static';
                }
            } else {
                if (sidebar && sidebar.style.position === 'static') {
                    sidebar.style.position = 'sticky';
                }
            }
            
            // Update pagination for new screen size
            if (repositoryData && repositoryData.files) {
                updatePagination();
            }
        });

        // Show/hide footer based on scroll position
        let footerTimeout;
        window.addEventListener('scroll', function() {
            const footer = document.querySelector('.footer');
            if (!footer) return;
            
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;
            
            // Show footer when user scrolls to within 200px of the bottom
            const nearBottom = scrollTop + windowHeight >= documentHeight - 200;
            
            if (nearBottom) {
                footer.classList.add('show');
                // Hide footer after 3 seconds of no scrolling
                clearTimeout(footerTimeout);
                footerTimeout = setTimeout(() => {
                    footer.classList.remove('show');
                }, 3000);
            } else {
                footer.classList.remove('show');
                clearTimeout(footerTimeout);
            }
        });

        // Add keyboard navigation for pagination
        document.addEventListener('keydown', function(e) {
            if (currentView === 'human' && repositoryData && totalPages > 1) {
                if (e.key === 'ArrowLeft' && currentPage > 1) {
                    e.preventDefault();
                    goToPage(currentPage - 1);
                } else if (e.key === 'ArrowRight' && currentPage < totalPages) {
                    e.preventDefault();
                    goToPage(currentPage + 1);
                }
            }
            
            // Existing LLM view keyboard shortcut
            if (currentView === 'llm' && (e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                const textarea = document.getElementById('llm-textarea');
                textarea.focus();
                textarea.select();
            }
        });

        // Progress tracking for large repositories
        let processedFiles = 0;
        let totalFilesToProcess = 0;

        function updateProgress(current, total) {
            if (total > 10) { // Only show progress for larger repos
                const percent = Math.round((current / total) * 100);
                const loadingText = document.querySelector('.loading span');
                if (loadingText) {
                    loadingText.textContent = `Processing repository... ${percent}% (${current}/${total} files)`;
                }
            }
        }

        // Enhanced UI update with categorized files and tree view
        function updateRepositoryUI() {
            if (!repositoryData) return;
            
            // Update repo info with enhanced statistics
            const repoInfoElement = document.getElementById('repo-info');
            const repoNameElement = document.getElementById('repo-name');
            const repoDescElement = document.getElementById('repo-description');
            
            if (repoNameElement && repositoryData.repoInfo) {
                repoNameElement.innerHTML = `
                    <a href="${repositoryData.repoInfo.html_url}" target="_blank" style="color: var(--accent-primary); text-decoration: none;">
                        ${repositoryData.repoInfo.full_name}
                    </a>
                `;
            }
            
            if (repoDescElement && repositoryData.repoInfo) {
                repoDescElement.textContent = repositoryData.repoInfo.description || 'No description available';
            }
            
            // Enhanced statistics
            const totalFiles = repositoryData.allFiles ? repositoryData.allFiles.length : 0;
            const renderedCount = repositoryData.files ? repositoryData.files.length : 0;
            const availableFiles = getAvailableFiles();
            const successfullyLoaded = availableFiles.length;
            const failedToLoad = renderedCount - successfullyLoaded;
            const skippedCount = totalFiles - renderedCount;
            
            const fileCountElement = document.getElementById('file-count');
            const totalSizeElement = document.getElementById('total-size');
            const mainLanguageElement = document.getElementById('main-language');
            
            if (fileCountElement) {
                fileCountElement.textContent = `${successfullyLoaded}/${renderedCount}/${totalFiles}`;
            }
            if (totalSizeElement) {
                totalSizeElement.textContent = formatBytes(repositoryData.totalSize || 0);
            }
            if (mainLanguageElement && repositoryData.repoInfo) {
                mainLanguageElement.textContent = repositoryData.repoInfo.language || 'Mixed';
            }
            
            // Add additional stats
            const statsContainer = document.querySelector('.repo-stats');
            if (statsContainer && repositoryData.repoInfo) {
                let statusText = `Files: <strong>${successfullyLoaded}/${renderedCount}/${totalFiles}</strong>`;
                if (failedToLoad > 0) {
                    statusText += ` <span style="color: var(--text-muted);">(${failedToLoad} failed to load)</span>`;
                }
                
                statsContainer.innerHTML = `
                    <span class="stat">${statusText}</span>
                    <span class="stat">Size: <strong>${formatBytes(repositoryData.totalSize || 0)}</strong></span>
                    <span class="stat">Language: <strong>${repositoryData.repoInfo.language || 'Mixed'}</strong></span>
                    <span class="stat">Skipped: <strong>${skippedCount}</strong></span>
                `;
            }
            
            if (repoInfoElement) {
                repoInfoElement.style.display = 'block';
            }
            
            // Generate enhanced file tree with directory structure
            generateFileTree();
            
            // Generate file sections with improved navigation
            generateEnhancedFileSections();
            
            // Add directory tree view
            addDirectoryTreeView();
            
            // Add skipped files summary
            addSkippedFilesSummary();
            
            // Generate CXML for LLM view
            if (repositoryData && repositoryData.files) {
                // Generate CXML asynchronously and update when ready
                generateCXML(repositoryData.files).then(cxml => {
                    const llmTextarea = document.getElementById('llm-textarea');
                    if (llmTextarea) {
                        llmTextarea.value = cxml;
                    }
                }).catch(error => {
                    console.error('Error generating CXML:', error);
                    const llmTextarea = document.getElementById('llm-textarea');
                    if (llmTextarea) {
                        llmTextarea.value = 'Error generating LLM format: ' + error.message;
                    }
                });
            }
        }

        // Enhanced file tree with directory grouping  
        function generateFileTree() {
            const fileTree = document.getElementById('file-tree');
            if (!fileTree || !repositoryData || !repositoryData.files) return;
            
            // Use helper function to get available files
            const availableFiles = getAvailableFiles();
            
            // Update the sidebar header to show file count
            const sidebarHeader = fileTree.parentElement.querySelector('h3');
            if (sidebarHeader) {
                sidebarHeader.innerHTML = `Files (${availableFiles.length}) <small style="color: var(--text-muted); font-weight: normal;">↕️ scroll</small>`;
            }
            
            fileTree.innerHTML = '';
            
            // Add "Back to top" link
            const backToTop = document.createElement('li');
            backToTop.innerHTML = '<a href="#top" style="color: var(--accent-primary); font-weight: bold;">↑ Back to top</a>';
            fileTree.appendChild(backToTop);
            
            // Sort files by structure with README.md first
            const sortedFiles = sortFilesByStructure([...availableFiles]);
            
            // Group files by directory while maintaining sort order
            const filesByDir = {};
            const dirOrder = [];
            
            sortedFiles.forEach(file => {
                const parts = file.path.split('/');
                const dir = parts.length > 1 ? parts.slice(0, -1).join('/') : '';
                const filename = parts[parts.length - 1];
                
                if (!filesByDir[dir]) {
                    filesByDir[dir] = [];
                    dirOrder.push(dir);
                }
                filesByDir[dir].push({ ...file, filename });
            });
            
            // Display files maintaining the sorted order
            dirOrder.forEach(dir => {
                // Add directory header if not root
                if (dir !== '') {
                    const dirLi = document.createElement('li');
                    dirLi.style.fontWeight = 'bold';
                    dirLi.style.color = 'var(--text-secondary)';
                    dirLi.style.marginTop = '0.5rem';
                    dirLi.textContent = `📁 ${dir}/`;
                    fileTree.appendChild(dirLi);
                }
                
                // Add files in directory (already sorted)
                filesByDir[dir].forEach(file => {
                    const li = document.createElement('li');
                    li.style.paddingLeft = dir === '' ? '0' : '1rem';
                    
                    const a = document.createElement('a');
                    const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                    a.href = `#file-${fileId}`;
                    
                    // Add icon for different file types
                    let icon = '';
                    if (isJupyterNotebook(file.filename)) {
                        icon = '📓 ';
                    } else if (isMarkdownFile(file.filename)) {
                        icon = '📝 ';
                    } else if (['py', 'js', 'ts', 'java', 'cpp', 'c', 'h'].includes(getFileExtension(file.filename))) {
                        icon = '⚡ ';
                    } else if (['json', 'xml', 'yaml', 'yml'].includes(getFileExtension(file.filename))) {
                        icon = '📋 ';
                    } else {
                        icon = '📄 ';
                    }
                    
                    a.textContent = icon + file.filename;
                    a.title = `${file.path} (${formatBytes(file.size)})`;
                    li.appendChild(a);
                    
                    // Add file size indicator
                    const sizeSpan = document.createElement('span');
                    sizeSpan.className = 'file-size';
                    sizeSpan.textContent = ` (${formatBytes(file.size)})`;
                    sizeSpan.style.color = 'var(--text-muted)';
                    sizeSpan.style.fontSize = '0.8em';
                    li.appendChild(sizeSpan);
                    
                    fileTree.appendChild(li);
                });
            });
        }

        // Generate file sections with better formatting
        function generateFileSections() {
            const filesContainer = document.getElementById('files-container');
            filesContainer.innerHTML = '';
            
            repositoryData.files.forEach((file, index) => {
                const section = document.createElement('div');
                section.className = 'file-section';
                const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                section.id = `file-${fileId}`;
                
                const header = document.createElement('div');
                header.className = 'file-header';
                header.innerHTML = `
                    <h3>${file.path}</h3>
                    <span class="file-size">${formatBytes(file.size)} • ${index + 1} of ${repositoryData.files.length}</span>
                `;
                
                const content = document.createElement('div');
                content.className = 'file-content';
                
                try {
                    content.innerHTML = renderFileContent(file.content, file.path);
                } catch (error) {
                    content.innerHTML = `<pre class="error">Error rendering file: ${error.message}</pre>`;
                }
                
                section.appendChild(header);
                section.appendChild(content);
                filesContainer.appendChild(section);
            });
        }

        // Enhanced error handling
        function handleApiError(error, context) {
            console.error(`${context}:`, error);
            
            if (error.message.includes('API rate limit')) {
                const token = document.getElementById('github-token').value.trim();
                if (!token) {
                    return 'GitHub API rate limit exceeded. Please add a GitHub Personal Access Token to continue. You can create one at https://github.com/settings/tokens with "public_repo" scope.';
                } else {
                    return error.message;
                }
            } else if (error.message.includes('Invalid GitHub token')) {
                return 'Invalid GitHub token. Please check your token and try again. Make sure it has "public_repo" scope.';
            } else if (error.message.includes('not found')) {
                return 'Repository not found. Please check the URL and make sure the repository is public.';
            } else if (error.message.includes('network')) {
                return 'Network error. Please check your internet connection.';
            } else {
                return `Error: ${error.message}`;
            }
        }

        // Main render repository function (updated to use enhanced features)
        async function renderRepository() {
            const repoInput = document.getElementById('repo-input');
            const repoUrl = repoInput.value.trim();
            
            if (!repoUrl) {
                alert('Please enter a GitHub repository URL');
                return;
            }
            
            const repoInfo = parseRepoUrl(repoUrl);
            if (!repoInfo) {
                alert('Please enter a valid GitHub repository URL (e.g., https://github.com/username/repository)');
                return;
            }
            
            try {
                // Check rate limit before starting
                await checkRateLimit();
                
                // Use enhanced rendering with branch support
                await renderRepositoryWithBranch(repoUrl, null); // null means use default branch
                
            } catch (error) {
                console.error('Error rendering repository:', error);
                const errorMsg = handleApiError(error, 'Repository rendering');
                alert(errorMsg);
            }
        }

        // Enhanced file tree function with directory grouping
        function generateFileTree() {
            const fileTree = document.getElementById('file-tree');
            if (!fileTree || !repositoryData || !repositoryData.files) return;
            
            // Update the sidebar header to show file count
            const sidebarHeader = fileTree.parentElement.querySelector('h3');
            if (sidebarHeader) {
                sidebarHeader.innerHTML = `Files (${repositoryData.files.length}) <small style="color: var(--text-muted); font-weight: normal;">↕️ scroll</small>`;
            }
            
            fileTree.innerHTML = '';
            
            // Add "Back to top" link
            const backToTop = document.createElement('li');
            backToTop.innerHTML = '<a href="#top" style="color: var(--accent-primary); font-weight: bold;">↑ Back to top</a>';
            fileTree.appendChild(backToTop);
            
            // Group files by directory
            const filesByDir = {};
            repositoryData.files.forEach(file => {
                const parts = file.path.split('/');
                const dir = parts.length > 1 ? parts.slice(0, -1).join('/') : '';
                const filename = parts[parts.length - 1];
                
                if (!filesByDir[dir]) {
                    filesByDir[dir] = [];
                }
                filesByDir[dir].push({ ...file, filename });
            });
            
            // Sort directories
            const sortedDirs = Object.keys(filesByDir).sort((a, b) => {
                if (a === '') return -1; // Root files first
                if (b === '') return 1;
                return a.localeCompare(b);
            });
            
            sortedDirs.forEach(dir => {
                // Add directory header if not root
                if (dir !== '') {
                    const dirLi = document.createElement('li');
                    dirLi.style.fontWeight = 'bold';
                    dirLi.style.color = 'var(--text-secondary)';
                    dirLi.style.marginTop = '0.5rem';
                    dirLi.textContent = `📁 ${dir}/`;
                    fileTree.appendChild(dirLi);
                }
                
                // Add files in directory
                filesByDir[dir].sort((a, b) => a.filename.localeCompare(b.filename)).forEach(file => {
                    const li = document.createElement('li');
                    li.style.paddingLeft = dir === '' ? '0' : '1rem';
                    
                    const a = document.createElement('a');
                    const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                    a.href = `#file-${fileId}`;
                    
                    // Add icon for different file types
                    let icon = '';
                    if (isJupyterNotebook(file.filename)) {
                        icon = '📓 ';
                    } else if (isMarkdownFile(file.filename)) {
                        icon = '📝 ';
                    } else if (['py', 'js', 'ts', 'java', 'cpp', 'c', 'h'].includes(getFileExtension(file.filename))) {
                        icon = '⚡ ';
                    } else if (['json', 'xml', 'yaml', 'yml'].includes(getFileExtension(file.filename))) {
                        icon = '📋 ';
                    } else {
                        icon = '📄 ';
                    }
                    
                    a.textContent = icon + file.filename;
                    a.title = `${file.path} (${formatBytes(file.size)})`;
                    li.appendChild(a);
                    
                    // Add file size indicator
                    const sizeSpan = document.createElement('span');
                    sizeSpan.className = 'file-size';
                    sizeSpan.textContent = ` (${formatBytes(file.size)})`;
                    sizeSpan.style.color = 'var(--text-muted)';
                    sizeSpan.style.fontSize = '0.8em';
                    li.appendChild(sizeSpan);
                    
                    fileTree.appendChild(li);
                });
            });
        }

        // Enhanced file sections with better navigation and pagination
        function generateEnhancedFileSections() {
            const filesContainer = document.getElementById('files-container');
            if (!filesContainer) return;
            
            filesContainer.innerHTML = '';
            
            if (!repositoryData || !repositoryData.files) return;
            
            // Use helper function to get available files and sort them by structure
            const availableFiles = getAvailableFiles();
            const sortedFiles = sortFilesByStructure([...availableFiles]);
            
            // Calculate pagination based on sorted files
            const totalFiles = sortedFiles.length;
            const startIndex = (currentPage - 1) * filesPerPage;
            const endIndex = Math.min(startIndex + filesPerPage, totalFiles);
            const filesToShow = sortedFiles.slice(startIndex, endIndex);
            
            filesToShow.forEach((file, index) => {
                const globalIndex = startIndex + index; // Global index across all files
                const section = document.createElement('div');
                section.className = 'file-section';
                const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                section.id = `file-${fileId}`;
                
                const header = document.createElement('div');
                header.className = 'file-header';
                header.innerHTML = `
                    <h3>
                        <span style="color: var(--text-muted);">${globalIndex + 1}.</span>
                        ${file.path}
                    </h3>
                    <span class="file-size">
                        ${formatBytes(file.size)} • 
                        ${isJupyterNotebook(file.path) ? 'NOTEBOOK' : (getFileExtension(file.path).toUpperCase() || 'TXT')} • 
                        ${globalIndex + 1} of ${totalFiles}
                    </span>
                `;
                
                const content = document.createElement('div');
                content.className = 'file-content';
                
                // Add lazy loading for file content
                if (file.content) {
                    // Content already loaded
                    try {
                        content.innerHTML = renderFileContent(file.content, file.path);
                    } catch (error) {
                        content.innerHTML = `<pre class="error">Error rendering file: ${error.message}</pre>`;
                    }
                } else {
                    // Add placeholder and lazy load
                    content.innerHTML = `
                        <div class="lazy-content" data-file-path="${file.path}" data-file-sha="${file.sha}">
                            <div class="loading">
                                <div class="spinner"></div>
                                Loading ${file.path}...
                            </div>
                        </div>
                    `;
                    
                    // Load content when section comes into view
                    const observer = new IntersectionObserver(async (entries) => {
                        entries.forEach(async (entry) => {
                            if (entry.isIntersecting) {
                                observer.unobserve(entry.target);
                                await loadFileContentLazy(entry.target, file);
                            }
                        });
                    }, { threshold: 0.1 });
                    
                    observer.observe(section);
                }
                
                // Add back to top link
                const backToTop = document.createElement('div');
                backToTop.className = 'back-top';
                backToTop.innerHTML = '<a href="#top" style="color: var(--accent-primary); text-decoration: none;">↑ Back to top</a>';
                backToTop.style.textAlign = 'right';
                backToTop.style.marginTop = '1rem';
                backToTop.style.padding = '0.5rem 0';
                backToTop.style.borderTop = '1px solid var(--border-secondary)';
                backToTop.style.fontSize = '0.9rem';
                
                section.appendChild(header);
                section.appendChild(content);
                section.appendChild(backToTop);
                filesContainer.appendChild(section);
            });
            
            // Update pagination after generating sections
            updatePagination();
        }

        // Lazy load file content when needed
        async function loadFileContentLazy(section, fileInfo) {
            const contentDiv = section.querySelector('.file-content');
            const lazyDiv = contentDiv.querySelector('.lazy-content');
            
            if (!lazyDiv) return;
            
            try {
                // Check cache first
                if (filesContentCache.has(fileInfo.path)) {
                    const cachedContent = filesContentCache.get(fileInfo.path);
                    contentDiv.innerHTML = renderFileContent(cachedContent, fileInfo.path);
                    return;
                }
                
                // Check if request is already pending
                if (pendingFileRequests.has(fileInfo.path)) {
                    const content = await pendingFileRequests.get(fileInfo.path);
                    contentDiv.innerHTML = renderFileContent(content, fileInfo.path);
                    return;
                }
                
                // Create new request
                const requestPromise = fetchSingleFileContent(fileInfo);
                pendingFileRequests.set(fileInfo.path, requestPromise);
                
                const content = await requestPromise;
                
                // Cache the content
                filesContentCache.set(fileInfo.path, content);
                pendingFileRequests.delete(fileInfo.path);
                
                // Update the file object with loaded content
                const fileIndex = repositoryData.files.findIndex(f => f.path === fileInfo.path);
                if (fileIndex >= 0) {
                    repositoryData.files[fileIndex].content = content;
                }
                
                // Render the content
                contentDiv.innerHTML = renderFileContent(content, fileInfo.path);
                
            } catch (error) {
                console.error(`Failed to load ${fileInfo.path}:`, error);
                contentDiv.innerHTML = `<pre class="error">Failed to load file: ${error.message}</pre>`;
                pendingFileRequests.delete(fileInfo.path);
            }
        }

        // Global variables for lazy loading
        let filesContentCache = new Map();
        let pendingFileRequests = new Map();

        // Fetch single file content with optimized methods
        async function fetchSingleFileContent(fileInfo) {
            const repoInfo = repositoryData.repoInfo;
            const owner = repoInfo.owner.login;
            const repo = repoInfo.name;
            const headers = getGitHubHeaders();
            
            const methods = [
                // Method 1: Raw GitHub content (no rate limit for public repos)
                {
                    name: 'raw',
                    fetch: () => fetch(`https://raw.githubusercontent.com/${owner}/${repo}/${repoInfo.default_branch}/${fileInfo.path}`)
                },
                // Method 2: Git Blob API (more efficient than Contents API)
                {
                    name: 'blob',
                    fetch: () => fetch(`https://api.github.com/repos/${owner}/${repo}/git/blobs/${fileInfo.sha}`, { headers })
                },
                // Method 3: Contents API (fallback)
                {
                    name: 'contents',
                    fetch: () => fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${fileInfo.path}`, { headers })
                }
            ];

            for (const method of methods) {
                try {
                    const response = await method.fetch();
                    
                    if (response.ok) {
                        let content;
                        
                        if (method.name === 'raw') {
                            content = await response.text();
                        } else if (method.name === 'blob') {
                            const data = await response.json();
                            content = data.encoding === 'base64' ? atob(data.content) : data.content;
                        } else { // contents
                            const data = await response.json();
                            content = atob(data.content);
                        }
                        
                        console.log(`✅ Fetched ${fileInfo.path} using ${method.name} method`);
                        return content;
                    }
                } catch (error) {
                    console.warn(`Failed to fetch ${fileInfo.path} using ${method.name}:`, error.message);
                    continue;
                }
            }
            
            throw new Error(`All methods failed for ${fileInfo.path}`);
        }

        // Lazy load file content when needed
        async function loadFileContentLazy(section, fileInfo) {
            const contentDiv = section.querySelector('.file-content');
            const lazyDiv = contentDiv.querySelector('.lazy-content');
            
            if (!lazyDiv) return;
            
            try {
                // Check cache first
                if (filesContentCache.has(fileInfo.path)) {
                    const cachedContent = filesContentCache.get(fileInfo.path);
                    contentDiv.innerHTML = renderFileContent(cachedContent, fileInfo.path);
                    return;
                }
                
                // Check if request is already pending
                if (pendingFileRequests.has(fileInfo.path)) {
                    const content = await pendingFileRequests.get(fileInfo.path);
                    contentDiv.innerHTML = renderFileContent(content, fileInfo.path);
                    return;
                }
                
                // Create new request
                const requestPromise = fetchSingleFileContent(fileInfo);
                pendingFileRequests.set(fileInfo.path, requestPromise);
                
                const content = await requestPromise;
                
                // Cache the content
                filesContentCache.set(fileInfo.path, content);
                pendingFileRequests.delete(fileInfo.path);
                
                // Update the file object with loaded content
                const fileIndex = repositoryData.files.findIndex(f => f.path === fileInfo.path);
                if (fileIndex >= 0) {
                    repositoryData.files[fileIndex].content = content;
                }
                
                // Render the content
                contentDiv.innerHTML = renderFileContent(content, fileInfo.path);
                
            } catch (error) {
                console.error(`Failed to load ${fileInfo.path}:`, error);
                contentDiv.innerHTML = `<pre class="error">Failed to load file: ${error.message}</pre>`;
                pendingFileRequests.delete(fileInfo.path);
            }
        }

        // Enhanced file sections with better navigation and pagination
        function generateEnhancedFileSections() {
            const filesContainer = document.getElementById('files-container');
            if (!filesContainer) return;
            
            filesContainer.innerHTML = '';
            
            if (!repositoryData || !repositoryData.files) return;
            
            // Calculate pagination
            const totalFiles = repositoryData.files.length;
            const startIndex = (currentPage - 1) * filesPerPage;
            const endIndex = Math.min(startIndex + filesPerPage, totalFiles);
            const filesToShow = repositoryData.files.slice(startIndex, endIndex);
            
            filesToShow.forEach((file, index) => {
                const globalIndex = startIndex + index; // Global index across all files
                const section = document.createElement('div');
                section.className = 'file-section';
                const fileId = file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
                section.id = `file-${fileId}`;
                
                const header = document.createElement('div');
                header.className = 'file-header';
                header.innerHTML = `
                    <h3>
                        <span style="color: var(--text-muted);">${globalIndex + 1}.</span>
                        ${file.path}
                    </h3>
                    <span class="file-size">
                        ${formatBytes(file.size)} • 
                        ${isJupyterNotebook(file.path) ? 'NOTEBOOK' : (getFileExtension(file.path).toUpperCase() || 'TXT')} • 
                        ${globalIndex + 1} of ${totalFiles}
                    </span>
                `;
                
                const content = document.createElement('div');
                content.className = 'file-content';
                
                // Add lazy loading for file content
                if (file.content) {
                    // Content already loaded
                    try {
                        content.innerHTML = renderFileContent(file.content, file.path);
                    } catch (error) {
                        content.innerHTML = `<pre class="error">Error rendering file: ${error.message}</pre>`;
                    }
                } else {
                    // Add placeholder and lazy load
                    content.innerHTML = `
                        <div class="lazy-content" data-file-path="${file.path}" data-file-sha="${file.sha}">
                            <div class="loading">
                                <div class="spinner"></div>
                                Loading ${file.path}...
                            </div>
                        </div>
                    `;
                    
                    // Load content when section comes into view
                    const observer = new IntersectionObserver(async (entries) => {
                        entries.forEach(async (entry) => {
                            if (entry.isIntersecting) {
                                observer.unobserve(entry.target);
                                await loadFileContentLazy(entry.target, file);
                            }
                        });
                    }, { threshold: 0.1 });
                    
                    observer.observe(section);
                }
                
                // Add back to top link
                const backToTop = document.createElement('div');
                backToTop.className = 'back-top';
                backToTop.innerHTML = '<a href="#top" style="color: var(--accent-primary); text-decoration: none;">↑ Back to top</a>';
                backToTop.style.textAlign = 'right';
                backToTop.style.marginTop = '1rem';
                backToTop.style.padding = '0.5rem 0';
                backToTop.style.borderTop = '1px solid var(--border-secondary)';
                backToTop.style.fontSize = '0.9rem';
                
                section.appendChild(header);
                section.appendChild(content);
                section.appendChild(backToTop);
                filesContainer.appendChild(section);
            });
            
            // Update pagination after generating sections
            updatePagination();
        }

        // Add directory tree view
        function addDirectoryTreeView() {
            if (!repositoryData.treeStructure) return;
            
            // Find the sidebar and add tree view before file list
            const sidebar = document.querySelector('.sidebar');
            const existingTree = document.getElementById('directory-tree');
            if (existingTree) {
                existingTree.remove();
            }
            
            const treeSection = document.createElement('div');
            treeSection.id = 'directory-tree';
            treeSection.innerHTML = `
                <h3 style="margin-bottom: 1rem; color: var(--text-primary); font-size: 1rem;">
                    📁 Directory Structure
                </h3>
                <pre style="
                    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
                    font-size: 0.8rem;
                    line-height: 1.2;
                    color: var(--text-secondary);
                    background: var(--bg-primary);
                    border: 1px solid var(--border-secondary);
                    border-radius: 4px;
                    padding: 0.75rem;
                    margin-bottom: 1.5rem;
                    overflow-x: auto;
                    max-height: 200px;
                    overflow-y: auto;
                ">${repositoryData.treeStructure}</pre>
            `;
            
            // Insert before the file list
            const fileTreeContainer = document.querySelector('.sidebar h3');
            if (fileTreeContainer) {
                sidebar.insertBefore(treeSection, fileTreeContainer);
            }
        }

        // Add skipped files summary
        function addSkippedFilesSummary() {
            if (!repositoryData.categorizedFiles) return;
            
            const { binary, large, ignored, failed, truncated } = repositoryData.categorizedFiles;
            // Don't count ignored files in the summary - they should be completely hidden
            const totalSkipped = binary.length + large.length + (failed ? failed.length : 0) + (truncated ? truncated.length : 0);
            
            if (totalSkipped === 0) return;
            
            // Find where to insert the summary (after repo info)
            const repoInfo = document.getElementById('repo-info');
            let summaryElement = document.getElementById('skipped-summary');
            
            if (!summaryElement) {
                summaryElement = document.createElement('div');
                summaryElement.id = 'skipped-summary';
                summaryElement.className = 'skipped-summary';
                summaryElement.style.cssText = `
                    background-color: var(--bg-secondary);
                    border: 1px solid var(--border-primary);
                    border-radius: 8px;
                    padding: 1rem;
                    margin-top: 1rem;
                `;
                repoInfo.parentNode.insertBefore(summaryElement, repoInfo.nextSibling);
            }
            
            let summaryHTML = `
                <h3 style="margin: 0 0 1rem 0; color: var(--text-primary); font-size: 1rem;">
                    📊 Skipped Files Summary (${totalSkipped})
                </h3>
            `;
            
            if (binary.length > 0) {
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            🔒 Binary files (${binary.length})
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${binary.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                            ${binary.length > 10 ? `<li><em>... and ${binary.length - 10} more</em></li>` : ''}
                        </ul>
                    </details>
                `;
            }
            
            if (large.length > 0) {
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            📦 Large files (${large.length}) - Over 100KB limit
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${large.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                            ${large.length > 10 ? `<li><em>... and ${large.length - 10} more</em></li>` : ''}
                        </ul>
                        <p style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.8rem; font-style: italic;">
                            💡 Note: Jupyter notebooks (.ipynb) are exempt from size limits and will always be processed.
                        </p>
                    </details>
                `;
            }
            
            if (ignored.length > 0) {
                // Ignored files are completely hidden - don't show them in summary
                // summaryHTML += `
                //     <details style="margin-bottom: 0.5rem;">
                //         <summary style="cursor: pointer; color: var(--text-secondary);">
                //             🙈 Git/ignored files (${ignored.length})
                //         </summary>
                //         <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                //             ${ignored.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                //             ${ignored.length > 10 ? `<li><em>... and ${ignored.length - 10} more</em></li>` : ''}
                //         </ul>
                //     </details>
                // `;
            }
            
            if (failed && failed.length > 0) {
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            ⚠️ Failed to fetch (${failed.length}) - Rate limit or API errors
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${failed.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)}) - ${f.category.reason}</li>`).join('')}
                            ${failed.length > 10 ? `<li><em>... and ${failed.length - 10} more</em></li>` : ''}
                        </ul>
                        <p style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.8rem; font-style: italic;">
                            💡 These files are likely text files but couldn't be fetched due to API rate limits or network errors. Try again later or add a GitHub token.
                        </p>
                    </details>
                `;
            }
            
            if (truncated && truncated.length > 0) {
                const currentLimit = getFileLimit();
                const githubToken = document.getElementById('github-token').value.trim();
                const isCustomLimit = document.getElementById('file-limit').value.trim() !== '';
                
                let limitDescription;
                if (isCustomLimit) {
                    limitDescription = `custom limit of ${currentLimit} files`;
                } else if (githubToken) {
                    limitDescription = `default limit of ${currentLimit} files (with GitHub token)`;
                } else {
                    limitDescription = `default limit of ${currentLimit} files (no GitHub token)`;
                }
                
                summaryHTML += `
                    <details style="margin-bottom: 0.5rem;">
                        <summary style="cursor: pointer; color: var(--text-secondary);">
                            ✂️ Truncated files (${truncated.length}) - Limited by ${limitDescription}
                        </summary>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.9rem;">
                            ${truncated.slice(0, 10).map(f => `<li><code>${f.path}</code> (${formatBytes(f.size)})</li>`).join('')}
                            ${truncated.length > 10 ? `<li><em>... and ${truncated.length - 10} more</em></li>` : ''}
                        </ul>
                        <div style="margin: 0.5rem 0; padding-left: 1.5rem; color: var(--text-muted); font-size: 0.8rem;">
                            ${isCustomLimit ? 
                                `💡 You set a custom limit of ${currentLimit} files. You can increase this limit (up to 1,000) in the file limit input above.` :
                                githubToken ? 
                                    `💡 Using default limit of ${currentLimit} files with GitHub token. You can set a custom limit (up to 1,000) in the file limit input above.` :
                                    `💡 Using default limit of ${currentLimit} files without GitHub token. Add a token to increase the default to 200 files, or set a custom limit (up to 1,000) above.`
                            }
                            <br><br>
                            🎯 <strong>Tip:</strong> Files are sorted by size (smallest first) to prioritize the most important content.
                        </div>
                    </details>
                `;
            }
            
            summaryElement.innerHTML = summaryHTML;
        }

        // Global variables for enhanced features
        let currentBranch = 'main';
        let availableBranches = [];
        let availableTags = [];
        let searchResults = [];
        let originalFilesList = null;
        let isSearchActive = false;
        let fileTypeStats = {};

        // Repository Browsing & Navigation Functions
        
        // Toggle advanced controls visibility
        function toggleAdvancedControls() {
            const branchControls = document.getElementById('branch-controls');
            const searchControls = document.getElementById('search-controls');
            const toggleBtn = document.getElementById('toggle-advanced-btn');
            
            const isVisible = branchControls.classList.contains('show');
            
            if (isVisible) {
                branchControls.classList.remove('show');
                searchControls.classList.remove('show');
                toggleBtn.classList.remove('active');
                toggleBtn.textContent = '⚙️ Advanced Controls';
            } else {
                branchControls.classList.add('show');
                searchControls.classList.add('show');
                toggleBtn.classList.add('active');
                toggleBtn.textContent = '⚙️ Hide Advanced Controls';
            }
        }

        // Fetch repository branches and tags
        async function fetchBranchesAndTags(owner, repo) {
            const headers = getGitHubHeaders();
            
            try {
                // Fetch branches
                const branchesResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/branches`, { headers });
                if (branchesResponse.ok) {
                    const branches = await branchesResponse.json();
                    availableBranches = branches.map(branch => ({
                        name: branch.name,
                        type: 'branch',
                        sha: branch.commit.sha,
                        protected: branch.protected || false
                    }));
                }
                
                // Fetch tags
                const tagsResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/tags`, { headers });
                if (tagsResponse.ok) {
                    const tags = await tagsResponse.json();
                    availableTags = tags.slice(0, 20).map(tag => ({ // Limit to 20 most recent tags
                        name: tag.name,
                        type: 'tag',
                        sha: tag.commit.sha
                    }));
                }
                
                populateBranchSelector();
                
            } catch (error) {
                console.warn('Failed to fetch branches/tags:', error);
            }
        }

        // Populate branch/tag selector
        function populateBranchSelector() {
            const branchSelect = document.getElementById('branch-select');
            if (!branchSelect) return;
            
            branchSelect.innerHTML = '';
            
            // Add branches
            if (availableBranches.length > 0) {
                const branchGroup = document.createElement('optgroup');
                branchGroup.label = '📂 Branches';
                availableBranches.forEach(branch => {
                    const option = document.createElement('option');
                    option.value = `branch:${branch.name}`;
                    option.textContent = `${branch.name}${branch.protected ? ' 🔒' : ''}`;
                    option.selected = branch.name === currentBranch;
                    branchGroup.appendChild(option);
                });
                branchSelect.appendChild(branchGroup);
            }
            
            // Add tags
            if (availableTags.length > 0) {
                const tagGroup = document.createElement('optgroup');
                tagGroup.label = '🏷️ Tags';
                availableTags.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = `tag:${tag.name}`;
                    option.textContent = tag.name;
                    tagGroup.appendChild(option);
                });
                branchSelect.appendChild(tagGroup);
            }
            
            // If no branches or tags found, show default branch
            if (availableBranches.length === 0 && availableTags.length === 0) {
                const option = document.createElement('option');
                option.value = `branch:${currentBranch}`;
                option.textContent = currentBranch;
                option.selected = true;
                branchSelect.appendChild(option);
            }
        }

        // Switch branch or tag
        async function switchBranchOrTag() {
            const branchSelect = document.getElementById('branch-select');
            if (!branchSelect || !repositoryData) return;
            
            const selectedValue = branchSelect.value;
            if (!selectedValue) return;
            
            const [type, name] = selectedValue.split(':');
            
            if (name === currentBranch) return; // No change needed
            
            try {
                // Update current branch
                currentBranch = name;
                
                // Clear current data
                clearSearchResults();
                resetFileView();
                
                // Show loading
                const loading = document.getElementById('loading');
                loading.style.display = 'flex';
                
                // Re-fetch repository with new branch/tag
                const repoUrl = `https://github.com/${repositoryData.repoInfo.owner.login}/${repositoryData.repoInfo.name}`;
                await renderRepositoryWithBranch(repoUrl, name);
                
            } catch (error) {
                console.error('Failed to switch branch/tag:', error);
                alert(`Failed to switch to ${type} "${name}": ${error.message}`);
                
                // Revert selection
                const currentOption = branchSelect.querySelector(`option[value="branch:${currentBranch}"]`);
                if (currentOption) {
                    currentOption.selected = true;
                }
            }
        }

        // Update commit info display
        function updateCommitInfo(commitData) {
            const commitInfo = document.getElementById('commit-info');
            const commitLink = document.getElementById('commit-link');
            const commitMessage = document.getElementById('commit-message');
            
            if (!commitData || !commitInfo) return;
            
            const shortSha = commitData.sha ? commitData.sha.substring(0, 7) : 'unknown';
            const message = commitData.commit?.message || 'No commit message';
            const commitUrl = commitData.html_url || '#';
            
            commitLink.href = commitUrl;
            commitLink.textContent = shortSha;
            commitMessage.textContent = message.split('\n')[0]; // First line only
            
            commitInfo.style.display = 'flex';
        }

        // Search & Filtering Functions
        
        // Generate file type statistics and filters
        function generateFileTypeFilters() {
            if (!repositoryData || !repositoryData.files) return;
            
            fileTypeStats = {};
            
            repositoryData.files.forEach(file => {
                const ext = getFileExtension(file.path);
                const type = ext || 'no-extension';
                fileTypeStats[type] = (fileTypeStats[type] || 0) + 1;
            });
            
            const fileTypeFilters = document.getElementById('file-type-filters');
            if (!fileTypeFilters) return;
            
            fileTypeFilters.innerHTML = '';
            
            // Sort by frequency
            const sortedTypes = Object.entries(fileTypeStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15); // Show top 15 file types
            
            sortedTypes.forEach(([type, count]) => {
                const badge = document.createElement('span');
                badge.className = 'file-type-badge';
                badge.dataset.fileType = type;
                badge.textContent = `${type === 'no-extension' ? '📄' : type} (${count})`;
                badge.onclick = () => toggleFileTypeFilter(type);
                fileTypeFilters.appendChild(badge);
            });
        }

        // Toggle file type filter
        function toggleFileTypeFilter(fileType) {
            const badge = document.querySelector(`[data-file-type="${fileType}"]`);
            if (!badge) return;
            
            const isActive = badge.classList.contains('active');
            
            if (isActive) {
                badge.classList.remove('active');
                clearFileTypeFilter();
            } else {
                // Clear other active badges
                document.querySelectorAll('.file-type-badge.active').forEach(b => b.classList.remove('active'));
                badge.classList.add('active');
                filterFilesByType(fileType);
            }
        }

        // Filter files by type
        function filterFilesByType(fileType) {
            if (!repositoryData || !repositoryData.files) return;
            
            const filteredFiles = repositoryData.files.filter(file => {
                const ext = getFileExtension(file.path);
                const type = ext || 'no-extension';
                return type === fileType;
            });
            
            displayFilteredFiles(filteredFiles, `Files with type: ${fileType}`);
        }

        // Clear file type filter
        function clearFileTypeFilter() {
            if (isSearchActive) {
                performSearch(); // Re-run search if search is active
            } else {
                resetFileView();
            }
        }

        // Handle search input with debouncing
        let searchTimeout;
        function handleSearchInput(event) {
            clearTimeout(searchTimeout);
            
            if (event.key === 'Enter') {
                performSearch();
                return;
            }
            
            // Debounce search for 300ms
            searchTimeout = setTimeout(() => {
                const query = event.target.value.trim();
                if (query.length >= 2) {
                    performSearch();
                } else if (query.length === 0) {
                    clearSearch();
                }
            }, 300);
        }

        // Perform search across files
        async function performSearch() {
            const searchInput = document.getElementById('search-input');
            const query = searchInput?.value.trim();
            
            if (!query || !repositoryData || !repositoryData.files) return;
            
            const searchBtn = document.getElementById('search-btn');
            searchBtn.disabled = true;
            searchBtn.textContent = '🔄 Searching...';
            
            try {
                // Get search options
                const searchFilenames = document.getElementById('filter-filenames')?.checked ?? true;
                const searchContent = document.getElementById('filter-content')?.checked ?? true;
                const isRegex = document.getElementById('regex-search')?.checked ?? false;
                const caseSensitive = document.getElementById('case-sensitive')?.checked ?? false;
                const codeOnly = document.getElementById('filter-code')?.checked ?? false;
                
                searchResults = [];
                
                // Prepare search pattern
                let searchPattern;
                if (isRegex) {
                    try {
                        searchPattern = new RegExp(query, caseSensitive ? 'g' : 'gi');
                    } catch (e) {
                        throw new Error(`Invalid regex pattern: ${e.message}`);
                    }
                } else {
                    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    searchPattern = new RegExp(escapedQuery, caseSensitive ? 'g' : 'gi');
                }
                
                // Define file type filters
                const codeExtensions = ['js', 'ts', 'py', 'java', 'cpp', 'c', 'h', 'cs', 'php', 'rb', 'go', 'rs', 'swift', 'kt'];
                
                for (const file of repositoryData.files) {
                    const ext = getFileExtension(file.path);
                    
                    // Apply file type filters
                    if (codeOnly && !codeExtensions.includes(ext)) continue;
                    
                    const matches = [];
                    
                    // Search in filename
                    if (searchFilenames) {
                        const filenameMatches = [...file.path.matchAll(searchPattern)];
                        if (filenameMatches.length > 0) {
                            matches.push({
                                type: 'filename',
                                text: file.path,
                                matches: filenameMatches.map(m => ({ index: m.index, text: m[0] }))
                            });
                        }
                    }
                    
                    // Search in content
                    if (searchContent && file.content) {
                        const lines = file.content.split('\n');
                        lines.forEach((line, lineNum) => {
                            const lineMatches = [...line.matchAll(searchPattern)];
                            if (lineMatches.length > 0) {
                                matches.push({
                                    type: 'content',
                                    lineNumber: lineNum + 1,
                                    text: line.trim(),
                                    matches: lineMatches.map(m => ({ index: m.index, text: m[0] }))
                                });
                            }
                        });
                    }
                    
                    // If content is not loaded yet, try to load it for search
                    if (searchContent && !file.content && matches.length === 0) {
                        try {
                            await loadFileContentForSearch(file);
                            const lines = file.content.split('\n');
                            lines.forEach((line, lineNum) => {
                                const lineMatches = [...line.matchAll(searchPattern)];
                                if (lineMatches.length > 0) {
                                    matches.push({
                                        type: 'content',
                                        lineNumber: lineNum + 1,
                                        text: line.trim(),
                                        matches: lineMatches.map(m => ({ index: m.index, text: m[0] }))
                                    });
                                }
                            });
                        } catch (error) {
                            console.warn(`Failed to load content for search: ${file.path}`, error);
                        }
                    }
                    
                    if (matches.length > 0) {
                        searchResults.push({
                            file,
                            matches,
                            totalMatches: matches.reduce((sum, match) => sum + match.matches.length, 0)
                        });
                    }
                }
                
                // Sort by relevance (filename matches first, then by number of matches)
                searchResults.sort((a, b) => {
                    const aHasFilename = a.matches.some(m => m.type === 'filename');
                    const bHasFilename = b.matches.some(m => m.type === 'filename');
                    
                    if (aHasFilename && !bHasFilename) return -1;
                    if (!aHasFilename && bHasFilename) return 1;
                    
                    return b.totalMatches - a.totalMatches;
                });
                
                displaySearchResults(query, searchResults);
                isSearchActive = true;
                
            } catch (error) {
                console.error('Search error:', error);
                alert(`Search error: ${error.message}`);
            } finally {
                searchBtn.disabled = false;
                searchBtn.textContent = '🔍 Search';
            }
        }

        // Load file content specifically for search
        async function loadFileContentForSearch(file) {
            if (file.content) return;
            
            // Check cache first
            if (filesContentCache.has(file.path)) {
                file.content = filesContentCache.get(file.path);
                return;
            }
            
            // Load content
            file.content = await fetchSingleFileContent(file);
            filesContentCache.set(file.path, file.content);
        }

        // Display search results
        function displaySearchResults(query, results) {
            const searchResultsContainer = document.getElementById('search-results');
            const searchResultsCount = document.getElementById('search-results-count');
            const searchResultsList = document.getElementById('search-results-list');
            
            if (!searchResultsContainer || !searchResultsCount || !searchResultsList) return;
            
            const totalMatches = results.reduce((sum, result) => sum + result.totalMatches, 0);
            
            searchResultsCount.textContent = `Found ${totalMatches} matches in ${results.length} files`;
            searchResultsList.innerHTML = '';
            
            if (results.length === 0) {
                searchResultsList.innerHTML = '<p style="color: var(--text-muted); text-align: center; padding: 2rem;">No matches found</p>';
            } else {
                results.slice(0, 50).forEach(result => { // Limit to 50 results for performance
                    const resultElement = createSearchResultElement(result, query);
                    searchResultsList.appendChild(resultElement);
                });
                
                if (results.length > 50) {
                    const moreElement = document.createElement('div');
                    moreElement.style.cssText = 'text-align: center; padding: 1rem; color: var(--text-muted);';
                    moreElement.textContent = `... and ${results.length - 50} more results`;
                    searchResultsList.appendChild(moreElement);
                }
            }
            
            searchResultsContainer.style.display = 'block';
            
            // Update main file view to show only matching files
            const matchingFiles = results.map(r => r.file);
            displayFilteredFiles(matchingFiles, `Search results for "${query}"`);
        }

        // Create search result element
        function createSearchResultElement(result, query) {
            const div = document.createElement('div');
            div.className = 'search-result-item';
            
            const fileId = result.file.path.replace(/[^a-zA-Z0-9-_]/g, '-');
            
            let matchesHTML = '';
            result.matches.slice(0, 5).forEach(match => { // Show up to 5 matches per file
                if (match.type === 'filename') {
                    matchesHTML += `<div class="search-result-preview">
                        <strong>Filename:</strong> ${highlightMatches(match.text, match.matches)}
                    </div>`;
                } else {
                    const contextText = truncateText(match.text, 100);
                    matchesHTML += `<div class="search-result-preview">
                        <strong>Line ${match.lineNumber}:</strong> ${highlightMatches(contextText, match.matches)}
                    </div>`;
                }
            });
            
            if (result.matches.length > 5) {
                matchesHTML += `<div style="color: var(--text-muted); font-size: 0.8rem; padding: 0.5rem;">
                    ... and ${result.matches.length - 5} more matches
                </div>`;
            }
            
            div.innerHTML = `
                <div class="search-result-header">
                    <a href="#file-${fileId}" class="search-result-file">${result.file.path}</a>
                    <span class="search-result-matches">${result.totalMatches} matches</span>
                </div>
                ${matchesHTML}
            `;
            
            return div;
        }

        // Highlight search matches in text
        function highlightMatches(text, matches) {
            if (!matches || matches.length === 0) return text;
            
            let highlightedText = text;
            let offset = 0;
            
            matches.forEach(match => {
                const start = match.index + offset;
                const end = start + match.text.length;
                const highlighted = `<span class="search-highlight">${match.text}</span>`;
                
                highlightedText = highlightedText.slice(0, start) + highlighted + highlightedText.slice(end);
                offset += highlighted.length - match.text.length;
            });
            
            return highlightedText;
        }

        // Truncate text to specified length
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            
            const truncated = text.substring(0, maxLength);
            const lastSpace = truncated.lastIndexOf(' ');
            return lastSpace > maxLength * 0.7 ? truncated.substring(0, lastSpace) + '...' : truncated + '...';
        }

        // Clear search and reset view
        function clearSearch() {
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            
            if (searchInput) searchInput.value = '';
            if (searchResults) searchResults.style.display = 'none';
            
            searchResults.length = 0;
            isSearchActive = false;
            
            clearActiveFileTypeFilters();
            resetFileView();
        }

        // Clear active file type filters
        function clearActiveFileTypeFilters() {
            document.querySelectorAll('.file-type-badge.active').forEach(badge => {
                badge.classList.remove('active');
            });
        }

        // Display filtered files
        function displayFilteredFiles(files, title) {
            if (!originalFilesList) {
                originalFilesList = [...repositoryData.files];
            }
            
            // Temporarily replace the files list
            repositoryData.files = files;
            
            // Reset pagination
            currentPage = 1;
            
            // Regenerate file sections and tree
            generateFileTree();
            generateEnhancedFileSections();
            
            // Update file count in sidebar
            const sidebarHeader = document.querySelector('.sidebar h3');
            if (sidebarHeader) {
                sidebarHeader.innerHTML = `${title} (${files.length}) <small style="color: var(--text-muted); font-weight: normal;">filtered</small>`;
            }
        }

        // Reset file view to original state
        function resetFileView() {
            if (originalFilesList) {
                repositoryData.files = originalFilesList;
                originalFilesList = null;
            }
            
            currentPage = 1;
            generateFileTree();
            generateEnhancedFileSections();
        }

        // Clear search results
        function clearSearchResults() {
            searchResults = [];
            isSearchActive = false;
            
            const searchInput = document.getElementById('search-input');
            const searchResultsContainer = document.getElementById('search-results');
            
            if (searchInput) searchInput.value = '';
            if (searchResultsContainer) searchResultsContainer.style.display = 'none';
        }

        // Render repository with specific branch/tag
        async function renderRepositoryWithBranch(repoUrl, branchOrTag) {
            const repoInfo = parseRepoUrl(repoUrl);
            if (!repoInfo) {
                throw new Error('Invalid repository URL');
            }
            
            // Update the repo input to reflect current URL
            const repoInput = document.getElementById('repo-input');
            if (repoInput) {
                repoInput.value = repoUrl;
            }
            
            try {
                // Fetch repository data with specified branch
                repositoryData = await fetchRepositoryContentsWithBranch(repoInfo.owner, repoInfo.repo, branchOrTag);
                currentBranch = branchOrTag;
                
                // Fetch branches and tags for navigation
                await fetchBranchesAndTags(repoInfo.owner, repoInfo.repo);
                
                // Update UI
                updateRepositoryUI();
                generateFileTypeFilters();
                
                // Show advanced controls
                const advancedToggle = document.getElementById('advanced-controls-toggle');
                if (advancedToggle) {
                    advancedToggle.style.display = 'block';
                }
                
                // Show results container
                const resultsContainer = document.getElementById('results-container');
                if (resultsContainer) {
                    resultsContainer.classList.add('show');
                }
                
                // Fetch latest commit info for the branch
                await fetchCommitInfo(repoInfo.owner, repoInfo.repo, branchOrTag);
                
            } catch (error) {
                throw error;
            }
        }

        // Fetch repository contents with specific branch
        async function fetchRepositoryContentsWithBranch(owner, repo, branchOrTag) {
            const loading = document.getElementById('loading');
            const renderBtn = document.getElementById('render-btn');
            
            loading.style.display = 'flex';
            renderBtn.disabled = true;
            
            try {
                const headers = getGitHubHeaders();
                
                // Fetch repository info
                const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
                if (!repoResponse.ok) {
                    if (repoResponse.status === 404) {
                        throw new Error('Repository not found or is private');
                    } else if (repoResponse.status === 403) {
                        const resetTime = repoResponse.headers.get('X-RateLimit-Reset');
                        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000).toLocaleTimeString() : 'unknown';
                        throw new Error(`API rate limit exceeded. Rate limit resets at ${resetDate}. Consider adding a GitHub token.`);
                    } else if (repoResponse.status === 401) {
                        throw new Error('Invalid GitHub token. Please check your token and try again.');
                    } else {
                        throw new Error(`Failed to fetch repository: ${repoResponse.status}`);
                    }
                }
                const repoInfo = await repoResponse.json();
                
                // Use specified branch or fall back to default
                const targetBranch = branchOrTag || repoInfo.default_branch;
                
                // Fetch repository tree for the target branch
                const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${targetBranch}?recursive=1`, { headers });
                if (!treeResponse.ok) {
                    if (treeResponse.status === 403) {
                        const resetTime = treeResponse.headers.get('X-RateLimit-Reset');
                        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000).toLocaleTimeString() : 'unknown';
                        throw new Error(`API rate limit exceeded while fetching repository tree. Rate limit resets at ${resetDate}. Consider adding a GitHub token.`);
                    }
                    throw new Error(`Failed to fetch repository contents for branch/tag: ${targetBranch}`);
                }
                const treeData = await treeResponse.json();
                
                // Process files as before
                const allFiles = [];
                const categorizedFiles = {
                    rendered: [],
                    binary: [],
                    large: [],
                    ignored: [],
                    failed: []
                };
                
                for (const item of treeData.tree) {
                    if (item.type === 'blob') {
                        const category = categorizeFile(item.path, item.size || 0);
                        
                        const fileInfo = {
                            path: item.path,
                            size: item.size || 0,
                            sha: item.sha,
                            category: category
                        };
                        
                        if (category.category !== 'ignored') {
                            allFiles.push(fileInfo);
                        }
                        
                        if (category.include) {
                            categorizedFiles.rendered.push(fileInfo);
                        } else {
                            const categoryKey = category.category === 'ignored' ? 'ignored' : 
                                              category.category === 'large' ? 'large' : 'binary';
                            categorizedFiles[categoryKey].push(fileInfo);
                        }
                    }
                }
                
                totalFilesToProcess = categorizedFiles.rendered.length;
                
                // Use the same file limit logic as the main function
                const maxFiles = getFileLimit();
                
                if (totalFilesToProcess > maxFiles) {
                    categorizedFiles.rendered = sortFilesByStructure(categorizedFiles.rendered);
                    const truncatedFiles = categorizedFiles.rendered.splice(maxFiles);
                    if (!categorizedFiles.truncated) categorizedFiles.truncated = [];
                    categorizedFiles.truncated.push(...truncatedFiles);
                    totalFilesToProcess = categorizedFiles.rendered.length;
                }
                
                const filesList = categorizedFiles.rendered.map(fileInfo => ({
                    path: fileInfo.path,
                    size: fileInfo.size,
                    sha: fileInfo.sha,
                    content: null
                }));
                
                return {
                    repoInfo: { ...repoInfo, currentBranch: targetBranch },
                    files: filesList,
                    categorizedFiles,
                    allFiles,
                    totalSize: categorizedFiles.rendered.reduce((sum, file) => sum + (file.size || 0), 0),
                    treeStructure: await generateTreeStructure(treeData.tree)
                };
                
            } catch (error) {
                throw error;
            } finally {
                loading.style.display = 'none';
                renderBtn.disabled = false;
            }
        }

        // Fetch commit information for branch/tag
        async function fetchCommitInfo(owner, repo, branchOrTag) {
            try {
                const headers = getGitHubHeaders();
                const commitsResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/commits/${branchOrTag}`, { headers });
                
                if (commitsResponse.ok) {
                    const commitData = await commitsResponse.json();
                    updateCommitInfo(commitData);
                }
            } catch (error) {
                console.warn('Failed to fetch commit info:', error);
            }
        }
    </script>
</body>
</html>